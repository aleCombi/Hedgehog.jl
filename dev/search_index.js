var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"This section is automatically generated from the public interface of Hedgehog.jl.","category":"page"},{"location":"api/#Hedgehog.AbstractCallPut","page":"API Reference","title":"Hedgehog.AbstractCallPut","text":"AbstractCallPut\n\nAbstract type representing whether an option is a call or a put.\n\n\n\n\n\n","category":"type"},{"location":"api/#Hedgehog.AbstractExerciseStyle","page":"API Reference","title":"Hedgehog.AbstractExerciseStyle","text":"AbstractExerciseStyle\n\nAbstract type representing the exercise style of an option (e.g., European or American).\n\n\n\n\n\n","category":"type"},{"location":"api/#Hedgehog.AbstractMarketInputs","page":"API Reference","title":"Hedgehog.AbstractMarketInputs","text":"AbstractMarketInputs\n\nAn abstract type representing market data inputs required for pricers.\n\n\n\n\n\n","category":"type"},{"location":"api/#Hedgehog.AbstractPayoff","page":"API Reference","title":"Hedgehog.AbstractPayoff","text":"AbstractPayoff\n\nAn abstract type representing a financial payoff, such as a vanilla European option, an Asian option, or a forward.\n\n\n\n\n\n","category":"type"},{"location":"api/#Hedgehog.AbstractPricingMethod","page":"API Reference","title":"Hedgehog.AbstractPricingMethod","text":"An abstract type representing a pricing method.\n\nAll pricing methods should inherit from this type.\n\n\n\n\n\n","category":"type"},{"location":"api/#Hedgehog.AbstractPricingSolution","page":"API Reference","title":"Hedgehog.AbstractPricingSolution","text":"AbstractPricingSolution\n\nAbstract base type for all financial instrument pricing solutions.\n\nSubtypes should encapsulate the results of a specific pricing method applied to a defined pricing problem.\n\n\n\n\n\n","category":"type"},{"location":"api/#Hedgehog.AbstractRateCurve","page":"API Reference","title":"Hedgehog.AbstractRateCurve","text":"AbstractRateCurve\n\nAbstract supertype for all rate curve representations (e.g., flat, interpolated).\n\n\n\n\n\n","category":"type"},{"location":"api/#Hedgehog.AbstractVolSurface","page":"API Reference","title":"Hedgehog.AbstractVolSurface","text":"AbstractVolSurface\n\nAbstract supertype for volatility surface representations.\n\n\n\n\n\n","category":"type"},{"location":"api/#Hedgehog.American","page":"API Reference","title":"Hedgehog.American","text":"American <: AbstractExerciseStyle\n\nRepresents an American-style option that can be exercised at any time before or at expiry.\n\n\n\n\n\n","category":"type"},{"location":"api/#Hedgehog.AnalyticGreek","page":"API Reference","title":"Hedgehog.AnalyticGreek","text":"AnalyticGreek <: GreekMethod\n\nGreek calculation method using closed-form analytic formulas.\n\n\n\n\n\n","category":"type"},{"location":"api/#Hedgehog.AnalyticSolution","page":"API Reference","title":"Hedgehog.AnalyticSolution","text":"AnalyticSolution{T <: Number, P<:PricingProblem, M <: AbstractPricingMethod} <: AbstractPricingSolution\n\nRepresents a pricing solution obtained using an analytical (closed-form) formula.\n\nFields\n\nproblem::P: The pricing problem definition (<: PricingProblem).\nmethod::M: The specific analytical method used (<: AbstractPricingMethod).\nprice::T: The calculated numerical price (<: Number).\n\n\n\n\n\n","category":"type"},{"location":"api/#Hedgehog.Antithetic","page":"API Reference","title":"Hedgehog.Antithetic","text":"struct Antithetic <: VarianceReductionStrategy\n\nAntithetic variates method for variance reduction by simulating mirrored noise paths.\n\n\n\n\n\n","category":"type"},{"location":"api/#Hedgehog.BasketPricingProblem","page":"API Reference","title":"Hedgehog.BasketPricingProblem","text":"BasketPricingProblem(payoffs, market_inputs)\n\nContainer for pricing several payoffs under a single market scenario.\n\nFields\n\npayoffs::Vector{P}       — collection of payoffs to be priced.\nmarket_inputs::M         — market data (yield curves, vols, etc.) shared by all payoffs.\n\n\n\n\n\n","category":"type"},{"location":"api/#Hedgehog.BasketPricingSolution","page":"API Reference","title":"Hedgehog.BasketPricingSolution","text":"BasketPricingSolution(problem, solutions)\n\nResult of solving a BasketPricingProblem.\n\nFields\n\nproblem::BasketPricingProblem — the original problem definition.\nsolutions::Vector{S}          — pricing results, one per payoff.\n\n\n\n\n\n","category":"type"},{"location":"api/#Hedgehog.BatchGreekProblem","page":"API Reference","title":"Hedgehog.BatchGreekProblem","text":"BatchGreekProblem{P,L}\n\nProblem definition for calculating multiple Greeks at once.\n\nFields\n\npricing_problem: The underlying pricing problem.\nlenses: A collection of lenses, each specifying a parameter to differentiate with respect to.\n\n\n\n\n\n","category":"type"},{"location":"api/#Hedgehog.BlackScholesAnalytic","page":"API Reference","title":"Hedgehog.BlackScholesAnalytic","text":"BlackScholesAnalytic <: AbstractPricingMethod\n\nAnalytical Black-Scholes pricing method.\n\nRepresents the closed-form Black-Scholes model for pricing European-style vanilla options. Assumes lognormal dynamics for the underlying asset with constant volatility and interest rate.\n\n\n\n\n\n","category":"type"},{"location":"api/#Hedgehog.BlackScholesExact","page":"API Reference","title":"Hedgehog.BlackScholesExact","text":"struct BlackScholesExact <: SimulationStrategy\n\nExact sampling of the Black-Scholes model using closed-form solution.\n\n\n\n\n\n","category":"type"},{"location":"api/#Hedgehog.BlackScholesInputs","page":"API Reference","title":"Hedgehog.BlackScholesInputs","text":"BlackScholesInputs <: AbstractMarketInputs\n\nMarket data inputs for the Black-Scholes model.\n\nFields\n\nreferenceDate: The date from which maturity is measured.\nrate: The risk-free interest rate (annualized).\nspot: The current spot price of the underlying asset.\nsigma: The volatility of the underlying asset (annualized).\n\nThis struct encapsulates the necessary inputs for pricing derivatives under the Black-Scholes model.\n\n\n\n\n\n","category":"type"},{"location":"api/#Hedgehog.CRRSolution","page":"API Reference","title":"Hedgehog.CRRSolution","text":"CRRSolution{T <: Number, P<:PricingProblem, M <: AbstractPricingMethod} <: AbstractPricingSolution\n\nRepresents a pricing solution obtained using the Cox-Ross-Rubinstein (CRR) binomial tree model.\n\nFields\n\nproblem::P: The pricing problem definition (<: PricingProblem).\nmethod::M: The specific CRR method configuration (<: AbstractPricingMethod).\nprice::T: The calculated numerical price (<: Number).\n\n\n\n\n\n","category":"type"},{"location":"api/#Hedgehog.CalibrationAlgo","page":"API Reference","title":"Hedgehog.CalibrationAlgo","text":"abstract type CalibrationAlgo\n\nMarker type for calibration algorithms. Subtypes include OptimizerAlgo for optimization-based calibration and RootFinderAlgo for root-finding-based single-point calibration.\n\n\n\n\n\n","category":"type"},{"location":"api/#Hedgehog.CalibrationProblem","page":"API Reference","title":"Hedgehog.CalibrationProblem","text":"CalibrationProblem{P, M, A, Accessor, I, Q}\n\nWraps a BasketPricingProblem and defines which market parameters should be calibrated using Accessors.jl access paths.\n\nFields\n\npricing_problem::BasketPricingProblem{P, M}: The basket of payoffs and shared market input.\npricing_method::A: The pricing method used (e.g., Black-Scholes).\naccessors::Vector{Accessor}: List of Accessors.jl lenses specifying which parameters to calibrate.\nquotes::Vector{Q}: Observed market prices to match.\ninitial_guess::Vector{I}: Initial guesses for each calibrated parameter.\n\n\n\n\n\n","category":"type"},{"location":"api/#Hedgehog.Call","page":"API Reference","title":"Hedgehog.Call","text":"Call <: AbstractCallPut\n\nRepresents a call option.\n\n\n\n\n\n","category":"type"},{"location":"api/#Hedgehog.Call-Tuple{}","page":"API Reference","title":"Hedgehog.Call","text":"(call_put::Call)() -> 1.0\n\nReturns the call-put indicator for a call option (+1).\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog.CarrMadan","page":"API Reference","title":"Hedgehog.CarrMadan","text":"CarrMadan <: AbstractPricingMethod\n\nFourier transform-based pricing method for European options.\n\nImplements the Carr-Madan method, which prices European options using the inverse Fourier transform of the characteristic function of the log-price under the risk-neutral measure.\n\nFields\n\nα: Damping factor to ensure integrability of the Fourier transform.\nbound: Integration bound for numerical quadrature.\ndynamics: The model dynamics providing the terminal characteristic function.\nkwargs: Additional keyword arguments passed to the integral solver.\n\n\n\n\n\n","category":"type"},{"location":"api/#Hedgehog.CarrMadan-2","page":"API Reference","title":"Hedgehog.CarrMadan","text":"CarrMadan(α, bound, dynamics; kwargs...)\n\nConstructs a CarrMadan method with optional integration settings for quadgk.\n\nArguments\n\nα: Damping factor.\nbound: Integration bound (positive real number).\ndynamics: The price dynamics (must support marginal_law).\nkwargs...: Additional keyword arguments for quadgk.\n\n\n\n\n\n","category":"type"},{"location":"api/#Hedgehog.CarrMadanSolution","page":"API Reference","title":"Hedgehog.CarrMadanSolution","text":"CarrMadanSolution{T <: Number, P<:PricingProblem, M <: AbstractPricingMethod} <: AbstractPricingSolution\n\nRepresents a pricing solution obtained using the Carr-Madan FFT-based method.\n\nThis method typically involves Fourier transforms and numerical integration for pricing options.\n\nFields\n\nproblem::P: The pricing problem definition (<: PricingProblem).\nmethod::M: The specific Carr-Madan method configuration (<: AbstractPricingMethod).\nprice::T: The calculated numerical price (<: Number).\nintegral_solution::SciMLBase.IntegralSolution: The solution object resulting from the numerical integration step (often FFT-based) involved in the Carr-Madan approach.\n\n\n\n\n\n","category":"type"},{"location":"api/#Hedgehog.CoxRossRubinsteinMethod","page":"API Reference","title":"Hedgehog.CoxRossRubinsteinMethod","text":"The Cox-Ross-Rubinstein binomial tree pricing method.\n\nThis struct represents the Cox-Ross-Rubinstein (CRR) binomial pricing model for option pricing.\n\nFields\n\nsteps: The number of time steps in the binomial tree.\n\nNotes\n\nThis implementation supports options written on either the forward price or the spot price.\nWhen pricing an option on the forward price, discounting is already embedded in the forward.\nWhen pricing an option on the spot price, discounting must be explicitly applied at each step.\nThe up probability is defined as:\n\np = 1 / (1 + u)\n\nwhere:\n\nu = exp(σ√ΔT) is the up-move factor,\nΔT is the time step duration in years.\n\n\n\n\n\n","category":"type"},{"location":"api/#Hedgehog.EulerMaruyama","page":"API Reference","title":"Hedgehog.EulerMaruyama","text":"struct EulerMaruyama <: SimulationStrategy\n\nEuler-Maruyama discretization for simulating SDEs.\n\n\n\n\n\n","category":"type"},{"location":"api/#Hedgehog.European","page":"API Reference","title":"Hedgehog.European","text":"European <: AbstractExerciseStyle\n\nRepresents a European-style option that can only be exercised at expiry.\n\n\n\n\n\n","category":"type"},{"location":"api/#Hedgehog.FDBackward","page":"API Reference","title":"Hedgehog.FDBackward","text":"FDBackward <: FDScheme\n\nFinite difference scheme using backward differencing.\n\n\n\n\n\n","category":"type"},{"location":"api/#Hedgehog.FDCentral","page":"API Reference","title":"Hedgehog.FDCentral","text":"FDCentral <: FDScheme\n\nFinite difference scheme using central differencing.\n\n\n\n\n\n","category":"type"},{"location":"api/#Hedgehog.FDForward","page":"API Reference","title":"Hedgehog.FDForward","text":"FDForward <: FDScheme\n\nFinite difference scheme using forward differencing.\n\n\n\n\n\n","category":"type"},{"location":"api/#Hedgehog.FDScheme","page":"API Reference","title":"Hedgehog.FDScheme","text":"FDScheme\n\nAbstract type representing different finite difference schemes.\n\n\n\n\n\n","category":"type"},{"location":"api/#Hedgehog.FiniteDifference","page":"API Reference","title":"Hedgehog.FiniteDifference","text":"FiniteDifference{S<:FDScheme, A <: Number} <: GreekMethod\n\nGreek calculation method using finite differences.\n\nFields\n\nbump: The bump size for finite difference.\nscheme: The finite difference scheme to use.\n\n\n\n\n\n","category":"type"},{"location":"api/#Hedgehog.FiniteDifference-Tuple{Any}","page":"API Reference","title":"Hedgehog.FiniteDifference","text":"FiniteDifference(bump)\n\nConvenience constructor for central finite differencing with a specified bump size.\n\nArguments\n\nbump: The bump size for finite difference.\n\nReturns\n\nA FiniteDifference object with a central scheme.\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog.FlatRateCurve","page":"API Reference","title":"Hedgehog.FlatRateCurve","text":"FlatRateCurve{R <: Number, S <: Number} <: AbstractRateCurve\n\nRepresents a flat curve with a constant continuously compounded zero rate.\n\nFields\n\nreference_date::R: The reference date for the curve, in internal tick units.\nrate::S: The constant zero rate applied across all tenors.\n\n\n\n\n\n","category":"type"},{"location":"api/#Hedgehog.FlatRateCurve-Tuple{Number}","page":"API Reference","title":"Hedgehog.FlatRateCurve","text":"FlatRateCurve(rate::Number; reference_date::TimeType = Date(0))\n\nCreates a flat curve with constant zero rate.\n\nArguments\n\nrate: The constant continuously compounded rate.\nreference_date: The reference date (default is the Julia epoch).\n\nReturns\n\nA FlatRateCurve instance.\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog.FlatVolSurface","page":"API Reference","title":"Hedgehog.FlatVolSurface","text":"FlatVolSurface(σ::Real)\n\nVolatility surface with a constant volatility σ.\n\n\n\n\n\n","category":"type"},{"location":"api/#Hedgehog.Forward","page":"API Reference","title":"Hedgehog.Forward","text":"Forward <: Underlying\n\nRepresents an underlying defined in terms of forward price.\n\n\n\n\n\n","category":"type"},{"location":"api/#Hedgehog.ForwardAD","page":"API Reference","title":"Hedgehog.ForwardAD","text":"ForwardAD <: GreekMethod\n\nGreek calculation method using forward-mode automatic differentiation.\n\n\n\n\n\n","category":"type"},{"location":"api/#Hedgehog.GreekLens","page":"API Reference","title":"Hedgehog.GreekLens","text":"GreekLens\n\nAbstract supertype for all lens types used to extract or modify model inputs (e.g., spot, volatilities, rates) for sensitivity analysis or automatic differentiation.\n\nConcrete subtypes define how to access and mutate a particular model input from a PricingProblem.\n\n\n\n\n\n","category":"type"},{"location":"api/#Hedgehog.GreekMethod","page":"API Reference","title":"Hedgehog.GreekMethod","text":"GreekMethod\n\nAbstract type representing different methods for Greek calculation.\n\n\n\n\n\n","category":"type"},{"location":"api/#Hedgehog.GreekProblem","page":"API Reference","title":"Hedgehog.GreekProblem","text":"GreekProblem{P,L}\n\nProblem definition for calculating a first-order Greek.\n\nFields\n\npricing_problem: The underlying pricing problem.\nwrt: The lens specifying which parameter to differentiate with respect to.\n\n\n\n\n\n","category":"type"},{"location":"api/#Hedgehog.GreekResult","page":"API Reference","title":"Hedgehog.GreekResult","text":"GreekResult{T}\n\nContainer for the result of a Greek calculation.\n\nFields\n\ngreek: The calculated Greek value.\n\n\n\n\n\n","category":"type"},{"location":"api/#Hedgehog.HestonBroadieKaya","page":"API Reference","title":"Hedgehog.HestonBroadieKaya","text":"struct HestonBroadieKaya <: SimulationStrategy\n\nExact sampling scheme for the Heston model using the Broadie-Kaya method.\n\n\n\n\n\n","category":"type"},{"location":"api/#Hedgehog.HestonCFIterator","page":"API Reference","title":"Hedgehog.HestonCFIterator","text":"HestonCFIterator\n\nPrecomputes constants for efficient evaluation of the characteristic function of ∫₀ᵗ V_s ds.\n\n\n\n\n\n","category":"type"},{"location":"api/#Hedgehog.HestonCFIterator-Tuple{Any, Hedgehog.HestonDistribution}","page":"API Reference","title":"Hedgehog.HestonCFIterator","text":"HestonCFIterator(VT, dist::HestonDistribution)\n\nConstructs a HestonCFIterator used for evaluating the characteristic function of the integral of variance.\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog.HestonDistribution","page":"API Reference","title":"Hedgehog.HestonDistribution","text":"HestonDistribution <: ContinuousMultivariateDistribution\n\nContainer type for Heston model parameters, used for exact sampling. Fields:\n\nS0, V0: initial spot and variance\nκ, θ, σ, ρ: mean reversion, long-term variance, vol-of-vol, and correlation\nr, T: risk-free rate and maturity\n\n\n\n\n\n","category":"type"},{"location":"api/#Hedgehog.HestonDynamics","page":"API Reference","title":"Hedgehog.HestonDynamics","text":"struct HestonDynamics <: PriceDynamics\n\nStochastic volatility model where the variance follows a Cox-Ingersoll-Ross (CIR) process.\n\n\n\n\n\n","category":"type"},{"location":"api/#Hedgehog.HestonInputs","page":"API Reference","title":"Hedgehog.HestonInputs","text":"HestonInputs <: AbstractMarketInputs\n\nMarket data inputs for the Heston stochastic volatility model.\n\nFields\n\nreferenceDate: The base date for maturity calculation (in ticks).\nrate: The risk-free interest rate (annualized).\nspot: The current spot price of the underlying.\nV0: The initial variance of the underlying.\nκ: The rate at which variance reverts to its long-term mean.\nθ: The long-term mean of the variance.\nσ: The volatility of variance (vol-of-vol).\nρ: The correlation between the asset and variance processes.\n\nUsed for pricing under the Heston model and simulation of stochastic volatility paths.\n\n\n\n\n\n","category":"type"},{"location":"api/#Hedgehog.Interpolator2D","page":"API Reference","title":"Hedgehog.Interpolator2D","text":"Interpolator2D{T, S, U, F}\n\nA 2D interpolation structure where:\n\nx_vals: grid in the x-direction (e.g., expiry),\ny_vals: grid in the y-direction (e.g., strike),\ny_interps: interpolators in the y-direction, one per x,\nbuild_x_interp: a function y ↦ x-interpolator built from applying all y-interpolators at y.\n\n\n\n\n\n","category":"type"},{"location":"api/#Hedgehog.Interpolator2D-Tuple{AbstractVector, AbstractVector, AbstractMatrix}","page":"API Reference","title":"Hedgehog.Interpolator2D","text":"Interpolator2D(x_vals, y_vals, values; kwargs...)\n\nReturns an Interpolator2D using interpolation and extrapolation logic along each axis. Used for reconstructing updated surfaces after calibration or bumping.\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog.LSM","page":"API Reference","title":"Hedgehog.LSM","text":"LSM <: AbstractPricingMethod\n\nLeast Squares Monte Carlo (LSM) pricing method for American options.\n\nUses regression to estimate continuation values and determine optimal stopping times.\n\nFields\n\nmc_method: A MonteCarlo method specifying dynamics and simulation strategy.\ndegree: Degree of the polynomial basis for regression.\n\n\n\n\n\n","category":"type"},{"location":"api/#Hedgehog.LSM-Tuple{Hedgehog.PriceDynamics, Hedgehog.SimulationStrategy, SimulationConfig, Int64}","page":"API Reference","title":"Hedgehog.LSM","text":"LSM(dynamics::PriceDynamics, strategy::SimulationStrategy, config::SimulationConfig, degree::Int)\n\nConstructs an LSM pricing method with polynomial regression and Monte Carlo simulation.\n\nArguments\n\ndynamics: Price dynamics.\nstrategy: Simulation strategy.\nconfig: Monte Carlo configuration.\ndegree: Degree of polynomial regression.\n\nReturns\n\nAn LSM instance.\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog.LSMSolution","page":"API Reference","title":"Hedgehog.LSMSolution","text":"LSMSolution{T <: Number,S,TEl, P<:PricingProblem, M <: AbstractPricingMethod} <: AbstractPricingSolution\n\nRepresents a pricing solution obtained using the Longstaff-Schwartz Method (LSM), typically applied to American-style options via Monte Carlo simulation.\n\nFields\n\nproblem::P: The pricing problem definition (<: PricingProblem), usually involving early exercise features.\nmethod::M: The specific LSM configuration (<: AbstractPricingMethod).\nprice::T: The calculated numerical price (<: Number).\nstopping_info::Vector{Tuple{Int,S}}: Information related to the derived optimal stopping (exercise) rule at different time steps. Often contains time indices and associated data S (e.g., regression coefficients, exercise boundaries).\nspot_paths::Matrix{TEl}: The matrix of simulated underlying asset price paths used in the LSM algorithm. TEl is the element type of the path values.\n\n\n\n\n\n","category":"type"},{"location":"api/#Hedgehog.LognormalDynamics","page":"API Reference","title":"Hedgehog.LognormalDynamics","text":"struct LognormalDynamics <: PriceDynamics\n\nPrice process follows geometric Brownian motion (Black-Scholes model).\n\n\n\n\n\n","category":"type"},{"location":"api/#Hedgehog.MonteCarlo","page":"API Reference","title":"Hedgehog.MonteCarlo","text":"struct MonteCarlo{P<:PriceDynamics, S<:SimulationStrategy, C<:SimulationConfig}\n\nMonte Carlo pricing method combining price dynamics, simulation strategy, and configuration.\n\nFields\n\ndynamics: The model for asset price dynamics.\nstrategy: Numerical simulation method.\nconfig: Simulation configuration (paths, steps, seeds, etc.).\n\n\n\n\n\n","category":"type"},{"location":"api/#Hedgehog.MonteCarloSolution","page":"API Reference","title":"Hedgehog.MonteCarloSolution","text":"MonteCarloSolution{T<:Number, S, P<:PricingProblem, M <: AbstractPricingMethod} <: AbstractPricingSolution\n\nRepresents a pricing solution obtained using a Monte Carlo simulation method.\n\nFields\n\nproblem::P: The pricing problem definition (<: PricingProblem).\nmethod::M: The specific Monte Carlo method used (<: AbstractPricingMethod).\nprice::T: The calculated numerical price (<: Number).\nensemble::S: The results of the Monte Carlo simulation (e.g., simulated paths or final values). The type S depends on the specific ensemble data stored.\n\n\n\n\n\n","category":"type"},{"location":"api/#Hedgehog.NoVarianceReduction","page":"API Reference","title":"Hedgehog.NoVarianceReduction","text":"struct NoVarianceReduction <: VarianceReductionStrategy\n\nStandard Monte Carlo simulation without variance reduction.\n\n\n\n\n\n","category":"type"},{"location":"api/#Hedgehog.OptimizerAlgo","page":"API Reference","title":"Hedgehog.OptimizerAlgo","text":"OptimizerAlgo{D, O}\n\nA calibration algorithm using optimization. D is the differentiation backend (e.g., AutoForwardDiff()), and O is the optimization algorithm (e.g., LBFGS()).\n\n\n\n\n\n","category":"type"},{"location":"api/#Hedgehog.OptimizerAlgo-Tuple{}","page":"API Reference","title":"Hedgehog.OptimizerAlgo","text":"OptimizerAlgo()\n\nConstructs an OptimizerAlgo with AutoForwardDiff() and LBFGS() as defaults.\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog.PriceDynamics","page":"API Reference","title":"Hedgehog.PriceDynamics","text":"abstract type PriceDynamics\n\nAbstract supertype for all models describing the stochastic dynamics of asset prices.\n\n\n\n\n\n","category":"type"},{"location":"api/#Hedgehog.PricingProblem","page":"API Reference","title":"Hedgehog.PricingProblem","text":"A PricingProblem bundles the payoff and the market inputs required to price a derivative.\n\nType Parameters\n\nP<:AbstractPayoff: The payoff type (e.g., VanillaOption).\nM<:AbstractMarketInputs: The market data type (e.g., volatility surface, interest rate curve).\n\nFields\n\npayoff::P: The payoff object describing the contract to be priced.\nmarket::M: The market data needed for pricing.\n\n\n\n\n\n","category":"type"},{"location":"api/#Hedgehog.Put","page":"API Reference","title":"Hedgehog.Put","text":"Put <: AbstractCallPut\n\nRepresents a put option.\n\n\n\n\n\n","category":"type"},{"location":"api/#Hedgehog.Put-Tuple{}","page":"API Reference","title":"Hedgehog.Put","text":"(call_put::Put)() -> -1.0\n\nReturns the call-put indicator for a put option (-1).\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog.RateCurve","page":"API Reference","title":"Hedgehog.RateCurve","text":"RateCurve{F, R <: Real, I <: DataInterpolations.AbstractInterpolation} <: AbstractRateCurve\n\nRepresents an interpolated rate curve based on zero rates derived from input discount factors.\n\nFields\n\nreference_date::R: The reference date for the curve, represented in internal tick units (e.g., milliseconds since epoch).\ninterpolator::I: An interpolation object (from DataInterpolations.jl) representing the zero rate curve as a function of year fractions.\nbuilder::F: A function (u, t) -> interpolator used to reconstruct the interpolator (e.g., during calibration), where u are zero rates and t are year fractions.\n\n\n\n\n\n","category":"type"},{"location":"api/#Hedgehog.RateCurve-Tuple{Dates.Date, AbstractVector, AbstractVector}","page":"API Reference","title":"Hedgehog.RateCurve","text":"RateCurve(reference_date::Date, tenors::AbstractVector, dfs::AbstractVector; interp = ...)\n\nDate-based overload for RateCurve.\n\nArguments\n\nreference_date: A Date object.\ntenors: Vector of year fractions.\ndfs: Discount factors.\ninterp: Interpolator builder.\n\nReturns\n\nA RateCurve instance.\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog.RateCurve-Tuple{Real, AbstractVector, AbstractVector}","page":"API Reference","title":"Hedgehog.RateCurve","text":"RateCurve(reference_date::Real, tenors::AbstractVector, dfs::AbstractVector; interp = ...)\n\nConstructs a RateCurve from discount factors and tenors.\n\nArguments\n\nreference_date: Time reference in internal tick units.\ntenors: Vector of year fractions (must be sorted and non-empty).\ndfs: Discount factors matching each tenor.\ninterp: A builder function (u, t) -> interpolator mapping zero rates and tenors to an interpolation object.\n\nReturns\n\nA RateCurve instance.\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog.RateCurve-Union{Tuple{F}, Tuple{I}, Tuple{Dates.Date, I, F}} where {I, F}","page":"API Reference","title":"Hedgehog.RateCurve","text":"RateCurve(reference_date::Date, itp::I, builder::F) where {I, F}\n\nConstructs a RateCurve from pre-built interpolation components and a Date.\n\nArguments\n\nreference_date: The date of the curve.\nitp: A DataInterpolations.AbstractInterpolation object.\nbuilder: The interpolator reconstruction function.\n\nReturns\n\nA RateCurve instance.\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog.RectVolSurface","page":"API Reference","title":"Hedgehog.RectVolSurface","text":"RectVolSurface(reference_date, interpolator, vols, builder)\n\nInternal constructor for a volatility surface using rectangular interpolation over a grid.\n\n\n\n\n\n","category":"type"},{"location":"api/#Hedgehog.RectVolSurface-Tuple{Any, Any, Any, AbstractVector, AbstractVector, AbstractMatrix}","page":"API Reference","title":"Hedgehog.RectVolSurface","text":"RectVolSurface(reference_date, rate, spot, tenors, strikes, prices; kwargs...)\n\nCalibrates a RectVolSurface from observed option prices. Handles optional call_put_matrix and allows customization of interpolation/extrapolation.\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog.RectVolSurface-Tuple{Union{Dates.Date, Dates.DateTime}, Interpolator2D, Matrix, Function}","page":"API Reference","title":"Hedgehog.RectVolSurface","text":"RectVolSurface(reference_date::Date, interpolator::Interpolator2D, vols, builder)\n\nWraps a tick-based surface into a RectVolSurface from a calendar reference_date.\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog.RectVolSurface-Union{Tuple{V}, Tuple{S}, Tuple{T}, Tuple{Any, Vector{T}, Vector{S}, Matrix{V}}} where {T<:Real, S<:Real, V<:Real}","page":"API Reference","title":"Hedgehog.RectVolSurface","text":"RectVolSurface(reference_date, tenors, strikes, vols; kwargs...)\n\nConstructs a rectangular volatility surface by interpolating across tenors and strikes.\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog.RootFinderAlgo","page":"API Reference","title":"Hedgehog.RootFinderAlgo","text":"RootFinderAlgo{R}\n\nCalibration algorithm using scalar root finding. Only supports single-instrument calibration.\n\n\n\n\n\n","category":"type"},{"location":"api/#Hedgehog.RootFinderAlgo-Tuple{}","page":"API Reference","title":"Hedgehog.RootFinderAlgo","text":"RootFinderAlgo()\n\nConstructs a RootFinderAlgo using the default method (Brent’s method inside NonlinearSolve).\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog.SecondOrderGreekProblem","page":"API Reference","title":"Hedgehog.SecondOrderGreekProblem","text":"SecondOrderGreekProblem{P,L1,L2}\n\nProblem definition for calculating a second-order Greek.\n\nFields\n\npricing_problem: The underlying pricing problem.\nwrt1: The first lens specifying the first parameter to differentiate with respect to.\nwrt2: The second lens specifying the second parameter to differentiate with respect to.\n\n\n\n\n\n","category":"type"},{"location":"api/#Hedgehog.SimulationConfig","page":"API Reference","title":"Hedgehog.SimulationConfig","text":"struct SimulationConfig{I, S, V<:VarianceReductionStrategy, TSeeds}\n\nConfiguration for Monte Carlo simulations.\n\nFields\n\ntrajectories: Number of Monte Carlo paths.\nsteps: Number of time steps in each simulation.\nvariance_reduction: Strategy to reduce variance (e.g., Antithetic()).\nseeds: Vector of RNG seeds used to initialize simulations for reproducibility.\n\n\n\n\n\n","category":"type"},{"location":"api/#Hedgehog.SimulationConfig-Tuple{Any}","page":"API Reference","title":"Hedgehog.SimulationConfig","text":"SimulationConfig(trajectories; steps=1, seeds=nothing, variance_reduction=Antithetic())\n\nConstructor for SimulationConfig. If seeds is not provided, random seeds are generated.\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog.SimulationStrategy","page":"API Reference","title":"Hedgehog.SimulationStrategy","text":"abstract type SimulationStrategy\n\nAbstract supertype for numerical strategies to simulate SDEs.\n\n\n\n\n\n","category":"type"},{"location":"api/#Hedgehog.Spot","page":"API Reference","title":"Hedgehog.Spot","text":"Spot <: Underlying\n\nRepresents an underlying defined in terms of spot price.\n\n\n\n\n\n","category":"type"},{"location":"api/#Hedgehog.SpotLens","page":"API Reference","title":"Hedgehog.SpotLens","text":"SpotLens <: GreekLens\n\nLens for accessing and modifying the spot price within a PricingProblem object.\n\nUsed to compute sensitivities (e.g., delta) with respect to the spot.\n\n\n\n\n\n","category":"type"},{"location":"api/#Hedgehog.SpotLens-Tuple{Any}","page":"API Reference","title":"Hedgehog.SpotLens","text":"(::SpotLens)(p::PricingProblem)\n\nExtract the spot value from the market_inputs field of the pricing problem p.\n\nArguments\n\np: A PricingProblem that contains market_inputs.spot.\n\nReturns\n\nThe current spot value.\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog.Underlying","page":"API Reference","title":"Hedgehog.Underlying","text":"Underlying\n\nAbstract type representing the nature of the underlying asset.\n\n\n\n\n\n","category":"type"},{"location":"api/#Hedgehog.VanillaOption","page":"API Reference","title":"Hedgehog.VanillaOption","text":"VanillaOption{TS,TE,E,C,U} <: AbstractPayoff\n\nA vanilla option with specified exercise style, call/put type, and underlying type.\n\nFields\n\nstrike: The strike price of the option.\nexpiry: The expiry (maturity) time in internal tick units.\nexercise_style: Instance of European or American.\ncall_put: Instance of Call or Put.\nunderlying: Either Spot or Forward.\n\n\n\n\n\n","category":"type"},{"location":"api/#Hedgehog.VanillaOption-Tuple{Any}","page":"API Reference","title":"Hedgehog.VanillaOption","text":"(payoff::VanillaOption)(spot)\n\nComputes the intrinsic payoff of a vanilla option for a given spot price or array of spot prices.\n\nArguments\n\npayoff: A VanillaOption instance.\nspot: A single spot price (Real) or an array of spot prices.\n\nReturns\n\nThe intrinsic value(s), i.e. max(cp * (S - K), 0), where cp is +1 for a call and -1 for a put.\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog.VanillaOption-Union{Tuple{TS}, Tuple{U}, Tuple{C}, Tuple{E}, Tuple{TS, Dates.TimeType, E, C, U}} where {E<:Hedgehog.AbstractExerciseStyle, C<:Hedgehog.AbstractCallPut, U<:Hedgehog.Underlying, TS<:Real}","page":"API Reference","title":"Hedgehog.VanillaOption","text":"VanillaOption(strike, expiry_date, exercise_style, call_put, underlying)\n\nConstructs a VanillaOption using a calendar expiry_date (e.g. Date, DateTime, etc.), which is converted internally to tick units via to_ticks.\n\nArguments\n\nstrike: Strike price of the option.\nexpiry_date: Maturity as a date/time object (converted to ticks).\nexercise_style: European() or American().\ncall_put: Call() or Put().\nunderlying: Spot() or Forward().\n\nReturns\n\nA fully constructed VanillaOption instance.\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog.VarianceReductionStrategy","page":"API Reference","title":"Hedgehog.VarianceReductionStrategy","text":"abstract type VarianceReductionStrategy\n\nAbstract supertype for variance reduction strategies used in Monte Carlo simulations.\n\n\n\n\n\n","category":"type"},{"location":"api/#Hedgehog.VolLens","page":"API Reference","title":"Hedgehog.VolLens","text":"VolLens(strike, expiry)\n\nLens structure for accessing and mutating specific vol entries by strike and expiry.\n\n\n\n\n\n","category":"type"},{"location":"api/#Hedgehog.VolLens-Tuple{Any}","page":"API Reference","title":"Hedgehog.VolLens","text":"(lens::VolLens)(prob)\n\nReads the volatility at a specific strike and expiry from a CalibrationProblem.\n\n\n\n\n\n","category":"method"},{"location":"api/#Accessors.set-Tuple{Any, SpotLens, Any}","page":"API Reference","title":"Accessors.set","text":"set(p::PricingProblem, ::SpotLens, newval)\n\nReturn a modified copy of the pricing problem p with its spot value updated to newval.\n\nArguments\n\np: A PricingProblem with a market_inputs field containing spot.\nnewval: The new value to assign to spot.\n\nReturns\n\nA new PricingProblem instance with updated spot value.\n\n\n\n\n\n","category":"method"},{"location":"api/#Accessors.set-Union{Tuple{T}, Tuple{S}, Tuple{Any, VolLens{S, T}, Any}} where {S, T}","page":"API Reference","title":"Accessors.set","text":"set(prob, lens::VolLens, new_val)\n\nReturns a modified CalibrationProblem with the volatility at the lens location updated to new_val.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.getindex-Tuple{Interpolator2D, Real, Real}","page":"API Reference","title":"Base.getindex","text":"Base.getindex(itp::Interpolator2D, x, y)\n\nEvaluate the 2D interpolator itp at point (x, y) using nested interpolation.\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog.HestonNoise","page":"API Reference","title":"Hedgehog.HestonNoise","text":"HestonNoise(μ, κ, θ, σ, ρ, t0, W0, Z0=nothing; kwargs...)\n\nConstructs a custom NoiseProcess using the exact Heston distribution for the next increment. Returns a NoiseProcess sampling from the Heston distribution at each timestep.\n\n\n\n\n\n","category":"function"},{"location":"api/#Hedgehog.HestonProblem-NTuple{7, Any}","page":"API Reference","title":"Hedgehog.HestonProblem","text":"HestonProblem(μ, κ, Θ, σ, ρ, u0, tspan; seed=UInt64(0), kwargs...)\n\nConstructs an SDEProblem representing the Heston model dynamics using Euler-Maruyama. Returns a SDEProblem with correlated Brownian motion and user-specified initial values.\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog._get_vol_lens-Tuple{Hedgehog.FlatVolSurface, Any, Any}","page":"API Reference","title":"Hedgehog._get_vol_lens","text":"_get_vol_lens(sigma::FlatVolSurface, _, _)\n\nReturns the constant volatility for a flat surface.\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog._get_vol_lens-Tuple{RectVolSurface, Real, Real}","page":"API Reference","title":"Hedgehog._get_vol_lens","text":"_get_vol_lens(sigma::RectVolSurface, expiry, strike)\n\nInternal helper to extract volatility from a rectangular surface at a given point. Throws an error if exact match is not found.\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog._set_vol_lens-Tuple{Hedgehog.FlatVolSurface, Any, Any, Any}","page":"API Reference","title":"Hedgehog._set_vol_lens","text":"_set_vol_lens(sigma::FlatVolSurface, _, _, new_val)\n\nReturns a new FlatVolSurface with updated constant volatility.\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog._set_vol_lens-Tuple{RectVolSurface, Real, Real, Any}","page":"API Reference","title":"Hedgehog._set_vol_lens","text":"_set_vol_lens(sigma::RectVolSurface, expiry, strike, new_val)\n\nInternal helper to return a new RectVolSurface with one vol entry updated. Rebuilds the interpolator.\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog.add_yearfrac-Tuple{Dates.TimeType, Real}","page":"API Reference","title":"Hedgehog.add_yearfrac","text":"add_yearfrac(t::TimeType, yf::Real) -> DateTime\n\nAdd a fractional number of years (yf, computed as ACT/365) to a Date or DateTime t.\n\nConverts t to milliseconds since the Julia Dates module epoch, adds the duration corresponding to yf, and converts the result back to a DateTime object.\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog.add_yearfrac-Tuple{Real, Real}","page":"API Reference","title":"Hedgehog.add_yearfrac","text":"add_yearfrac(t::Real, yf::Real) -> Real\n\nAdd a fractional number of years (yf, computed as ACT/365) to a timestamp t.\n\nThe timestamp t is assumed to be in milliseconds since the Julia Dates module epoch (0000-01-01T00:00:00). Returns the updated timestamp in milliseconds as Float64.\n\nThis version is AD-compatible.\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog.binomial_tree_underlying-Tuple{Any, Any, Any, Any, Any, Forward}","page":"API Reference","title":"Hedgehog.binomial_tree_underlying","text":"Computes the underlying asset price at a given step when pricing an option on the forward price.\n\nArguments\n\nforward: Forward price of the underlying asset.\n::Forward: Marker type indicating the option is written on the forward price.\n\nReturns\n\nThe forward price (unchanged, as forward prices already embed discounting).\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog.binomial_tree_underlying-Tuple{Any, Any, Any, Any, Any, Spot}","page":"API Reference","title":"Hedgehog.binomial_tree_underlying","text":"Computes the underlying asset price at a given step when pricing an option on the spot price.\n\nArguments\n\ntime_step: Current time step in the binomial tree.\nforward: Forward price of the underlying asset.\nrate: Risk-free rate.\ndelta_time: Time step size in years.\n::Spot: Marker type indicating the option is written on the spot price.\n\nReturns\n\nThe estimated spot price, derived by discounting the forward price.\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog.binomial_tree_value-Tuple{Any, Any, Any, Any, American}","page":"API Reference","title":"Hedgehog.binomial_tree_value","text":"Returns the value at a given node in the binomial tree for an American option.\n\nArguments\n\nstep: Current time step in the binomial tree.\ndiscounted_continuation: Discounted expected future values from the next step.\nunderlying_at_i: Function to compute the underlying price at a given step.\npayoff: Payoff function of the option.\n::American: Marker type for American exercise style.\n\nReturns\n\nThe maximum between the continuation value and the intrinsic value of the option (early exercise is considered).\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog.binomial_tree_value-Tuple{Any, Any, Any, Any, European}","page":"API Reference","title":"Hedgehog.binomial_tree_value","text":"Returns the value at a given node in the binomial tree for a European option.\n\nArguments\n\ndiscounted_continuation: Discounted expected future values from the next step.\n::European: Marker type for European exercise style.\n\nReturns\n\nThe continuation value, as European options do not allow early exercise.\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog.call_transform-Tuple{Any, Any, Any, Any, CarrMadan}","page":"API Reference","title":"Hedgehog.call_transform","text":"call_transform(rate, time, ϕ, v, method::CarrMadan)\n\nReturns the Fourier-space representation of the damped call payoff.\n\nArguments\n\nrate: Risk-free rate.\ntime: Time to maturity.\nϕ: Characteristic function of the log-price.\nv: Fourier variable.\nmethod: The CarrMadan pricing method instance.\n\nReturns\n\nThe value of the integrand for the Carr-Madan integral.\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog.cdf_from_cf-Tuple{Hedgehog.HestonCFIterator, Any, Any}","page":"API Reference","title":"Hedgehog.cdf_from_cf","text":"cdf_from_cf(ϕ_iter::HestonCFIterator, x, h; cf_tol=1e-4, kwargs...)\n\nApproximates the cumulative distribution function at x by numerically integrating the characteristic function. Implements the method of Broadie-Kaya with truncation tolerance cf_tol.\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog.cf-Tuple{Distributions.Normal, Any}","page":"API Reference","title":"Hedgehog.cf","text":"cf(d::Normal, t) -> Complex\n\nComputes the characteristic function of a normal distribution d evaluated at t.\n\nArguments\n\nd: A Normal distribution.\nt: The evaluation point (can be real or complex).\n\nReturns\n\nThe characteristic function value E[e^{itX}].\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog.cf-Tuple{Hedgehog.HestonDistribution, Any}","page":"API Reference","title":"Hedgehog.cf","text":"characteristic_function(d::HestonDistribution, u)\n\nComputes the characteristic function of log(S_T) under the Heston model at complex value u.\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog.compute_fd_derivative-Tuple{Hedgehog.FDForward, Vararg{Any, 4}}","page":"API Reference","title":"Hedgehog.compute_fd_derivative","text":"compute_fd_derivative(scheme::FDScheme, prob, lens, ε, pricing_method)\n\nCalculate numerical derivative using finite difference schemes.\n\nArguments\n\nscheme: The finite difference scheme to use (Forward, Backward, or Central).\nprob: The pricing problem.\nlens: The lens to access and modify the relevant parameter.\nε: The bump size for finite difference.\npricing_method: The method to price the derivative.\n\nReturns\n\nThe calculated finite difference derivative.\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog.df-Union{Tuple{D}, Tuple{R}, Tuple{R, D}} where {R<:Hedgehog.AbstractRateCurve, D<:Dates.TimeType}","page":"API Reference","title":"Hedgehog.df","text":"df(curve::AbstractRateCurve, t::TimeType)\n\nCompute the discount factor at a Date or DateTime.\n\nReturns\n\nDiscount factor as a real number.\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog.df-Union{Tuple{R}, Tuple{T}, Tuple{R, T}} where {T<:Number, R<:Hedgehog.AbstractRateCurve}","page":"API Reference","title":"Hedgehog.df","text":"df(curve::AbstractRateCurve, ticks::Number)\n\nCompute the discount factor at a given time point (in ticks).\n\nReturns\n\nDiscount factor as a real number.\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog.df_yf-Union{Tuple{T}, Tuple{R}, Tuple{R, T}} where {R<:Hedgehog.AbstractRateCurve, T<:Number}","page":"API Reference","title":"Hedgehog.df_yf","text":"df_yf(curve::AbstractRateCurve, yf::Number)\n\nCompute the discount factor from a year fraction.\n\nReturns\n\nDiscount factor as a real number.\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog.evaluate_chf-Union{Tuple{Tθ}, Tuple{Hedgehog.HestonCFIterator, Real, Tθ}} where Tθ","page":"API Reference","title":"Hedgehog.evaluate_chf","text":"evaluate_chf(iter::HestonCFIterator, a::Real, θ_prev)\n\nEvaluates the characteristic function at point a, unwrapping the angle using θ_prev to ensure continuity. Returns the characteristic function value and updated unwrapped angle.\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog.extract_spot_grid-Tuple{SciMLBase.EnsembleSolution}","page":"API Reference","title":"Hedgehog.extract_spot_grid","text":"extract_spot_grid(sol::EnsembleSolution)\n\nExtracts the simulated spot paths from an EnsembleSolution.\n\nArguments\n\nsol: The ensemble simulation result.\n\nReturns\n\nA matrix of spot values of size (nsteps, npaths).\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog.extract_spot_grid-Tuple{Tuple{SciMLBase.EnsembleSolution, SciMLBase.EnsembleSolution}}","page":"API Reference","title":"Hedgehog.extract_spot_grid","text":"extract_spot_grid(sol_anti::Tuple{EnsembleSolution, EnsembleSolution})\n\nExtracts spot paths from a pair of ensemble simulations with antithetic variates.\n\nArguments\n\nsol_anti: Tuple of original and antithetic ensemble simulations.\n\nReturns\n\nA matrix of spot values of size (nsteps, 2 * npaths).\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog.forward_rate-Tuple{RateCurve, Dates.Date, Dates.Date}","page":"API Reference","title":"Hedgehog.forward_rate","text":"forward_rate(curve::RateCurve, d1::Date, d2::Date)\n\nCalculate the forward rate between two dates.\n\nReturns\n\nForward rate as a real number.\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog.forward_rate-Tuple{RateCurve, Real, Real}","page":"API Reference","title":"Hedgehog.forward_rate","text":"forward_rate(curve::RateCurve, t1::Real, t2::Real)\n\nCalculate the forward rate between two year fractions.\n\nReturns\n\nForward rate as a real number.\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog.get_antithetic_ensemble_problem-Union{Tuple{S}, Tuple{Any, SciMLBase.EnsembleSolution, MonteCarlo{LognormalDynamics, BlackScholesExact, S}}} where S<:SimulationConfig","page":"API Reference","title":"Hedgehog.get_antithetic_ensemble_problem","text":"get_antithetic_ensemble_problem(problem, normal_sol, method)\n\nConstructs an ensemble problem by flipping volatility for exact Black-Scholes simulation.\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog.get_antithetic_ensemble_problem-Union{Tuple{S}, Tuple{P}, Tuple{Any, SciMLBase.EnsembleSolution, MonteCarlo{P, EulerMaruyama, S}}} where {P<:Hedgehog.PriceDynamics, S<:SimulationConfig}","page":"API Reference","title":"Hedgehog.get_antithetic_ensemble_problem","text":"get_antithetic_ensemble_problem(problem, normal_sol, method)\n\nConstructs an ensemble problem by mirroring noise from a base solution for Euler-Maruyama.\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog.get_ensemble_problem-Tuple{Any, SimulationConfig}","page":"API Reference","title":"Hedgehog.get_ensemble_problem","text":"get_ensemble_problem(prob, config)\n\nWraps a simulation problem into an EnsembleProblem with seed control.\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog.get_terminal_value-Tuple{Any, HestonDynamics, HestonBroadieKaya}","page":"API Reference","title":"Hedgehog.get_terminal_value","text":"get_terminal_value(path, dynamics, strategy)\n\nExtracts the terminal asset value from a simulated path, depending on model and strategy.\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog.get_vol-Tuple{Hedgehog.FlatVolSurface, Any, Any}","page":"API Reference","title":"Hedgehog.get_vol","text":"get_vol(surf::FlatVolSurface, _, _)\n\nReturns the constant volatility from a FlatVolSurface.\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog.get_vol-Tuple{RectVolSurface, Dates.Date, Real}","page":"API Reference","title":"Hedgehog.get_vol","text":"get_vol(surf::RectVolSurface, expiry_date::Date, strike)\n\nInterpolates the implied volatility for a given expiry_date and strike.\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog.get_vol-Union{Tuple{E}, Tuple{RectVolSurface, E, Any}} where E<:Real","page":"API Reference","title":"Hedgehog.get_vol","text":"get_vol(surf::RectVolSurface, expiry_time::Real, strike)\n\nInterpolates the implied volatility for a given time to expiry expiry_time and strike.\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog.get_vol_yf-Tuple{Hedgehog.FlatVolSurface, Any, Any}","page":"API Reference","title":"Hedgehog.get_vol_yf","text":"get_vol_yf(surf::FlatVolSurface, _, _)\n\nReturns the constant volatility from a FlatVolSurface, used when year fraction is precomputed.\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog.get_vol_yf-Tuple{RectVolSurface, Real, Real}","page":"API Reference","title":"Hedgehog.get_vol_yf","text":"get_vol_yf(surf::RectVolSurface, t, strike)\n\nLike get_vol, but assumes time to expiry t is already in year-fraction format.\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog.inverse_cdf-NTuple{4, Any}","page":"API Reference","title":"Hedgehog.inverse_cdf","text":"inverse_cdf(cdf_func, u, initial_guess, max_guess; atol=1E-4, maxiter_newton=10, maxiter_bisection=100, kwargs...)\n\nInverts a monotonic CDF to find x such that cdf_func(x) ≈ u.  Uses second-order Newton’s method (secant-style), falling back to bisection if needed.\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog.log_besseli_corrected-Tuple{Any, Complex, Ref{Float64}}","page":"API Reference","title":"Hedgehog.log_besseli_corrected","text":"log_besseli_corrected(ν, z, θ_ref)\n\nComputes the logarithm of the modified Bessel function of the first kind, correcting angle discontinuities. Used for numerical stability in CF evaluation.\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog.log_dynamics-Tuple{BlackScholesAnalytic}","page":"API Reference","title":"Hedgehog.log_dynamics","text":"log_dynamics(::BlackScholesAnalytic) -> LognormalDynamics\n\nReturns the assumed price dynamics under the Black-Scholes model.\n\nThis corresponds to lognormal dynamics with constant volatility and risk-free rate.\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog.log_dynamics-Tuple{CarrMadan}","page":"API Reference","title":"Hedgehog.log_dynamics","text":"log_dynamics(m::CarrMadan)\n\nReturns the log-price dynamics (distribution) used in the Carr-Madan method.\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog.marginal_law-Union{Tuple{I}, Tuple{P}, Tuple{PricingProblem{P, I}, HestonDynamics, Any}} where {P, I<:HestonInputs}","page":"API Reference","title":"Hedgehog.marginal_law","text":"marginal_law(problem::PricingProblem, ::HestonDynamics, t)\n\nReturns the marginal distribution of log-price under Heston dynamics at time t.\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog.marginal_law-Union{Tuple{I}, Tuple{P}, Tuple{PricingProblem{P, I}, LognormalDynamics, Any}} where {P, I<:BlackScholesInputs}","page":"API Reference","title":"Hedgehog.marginal_law","text":"marginal_law(problem::PricingProblem, ::LognormalDynamics, t)\n\nReturns the marginal distribution of log-price under Black-Scholes dynamics at time t.\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog.moments_from_cf-Tuple{Hedgehog.HestonCFIterator}","page":"API Reference","title":"Hedgehog.moments_from_cf","text":"moments_from_cf(ϕ_iter::HestonCFIterator; h=1e-4)\n\nEstimates the mean and variance from the characteristic function ϕ_iter using central differences.\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog.parity_transform-Union{Tuple{U}, Tuple{E}, Tuple{TE}, Tuple{TS}, Tuple{Any, VanillaOption{TS, TE, E, Call, U}, Any, Any}} where {TS, TE, E, U}","page":"API Reference","title":"Hedgehog.parity_transform","text":"parity_transform(call_price, opt::VanillaOption{T, E, Call, U}, spot, rate_curve)\n\nReturns the call price unchanged. Useful for unified pricing APIs that accept both calls and puts.\n\nArguments\n\ncall_price: Price of the call option.\nopt: A VanillaOption with Call() payoff.\nspot: Spot price.\nrate_curve: Rate curve.\n\nReturns\n\nThe same call_price, unchanged.\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog.parity_transform-Union{Tuple{U}, Tuple{E}, Tuple{TE}, Tuple{TS}, Tuple{Any, VanillaOption{TS, TE, E, Put, U}, Any, Any}} where {TS, TE, E, U}","page":"API Reference","title":"Hedgehog.parity_transform","text":"parity_transform(call_price, opt::VanillaOption{T, E, Put, U}, spot, rate_curve)\n\nApplies put-call parity to recover the put price from a known call price.\n\nArguments\n\ncall_price: Price of the call option.\nopt: A VanillaOption with Put() payoff.\nspot: Spot price.\nrate_curve: Rate curve.\n\nReturns\n\nThe corresponding put price using the formula: put = call - S + K * exp(-rT) where T is extracted from opt.expiry.\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog.rand-Tuple{Random.AbstractRNG, Hedgehog.HestonDistribution}","page":"API Reference","title":"Hedgehog.rand","text":"rand(rng, d::HestonDistribution; kwargs...)\n\nAlternative sampling version returning [log(S_T), V_T] instead of S_T. Useful for testing and diagnostics.\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog.reduce_payoffs-Union{Tuple{F}, Tuple{SciMLBase.EnsembleSolution, F, Hedgehog.NoVarianceReduction, Hedgehog.PriceDynamics, Hedgehog.SimulationStrategy}} where F","page":"API Reference","title":"Hedgehog.reduce_payoffs","text":"reduce_payoffs(result, payoff, ::NoVarianceReduction, dynamics, strategy)\n\nComputes the payoff from terminal values without applying variance reduction.\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog.reduce_payoffs-Union{Tuple{F}, Tuple{Tuple{SciMLBase.EnsembleSolution, SciMLBase.EnsembleSolution}, F, Hedgehog.Antithetic, Hedgehog.PriceDynamics, Hedgehog.SimulationStrategy}} where F","page":"API Reference","title":"Hedgehog.reduce_payoffs","text":"reduce_payoffs(result, payoff, ::Antithetic, dynamics, strategy)\n\nComputes the average payoff over paired antithetic paths.\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog.sample_V_T-Tuple{Random.AbstractRNG, Hedgehog.HestonDistribution}","page":"API Reference","title":"Hedgehog.sample_V_T","text":"sample_V_T(rng, d::HestonDistribution)\n\nSamples the terminal variance V_T from the noncentral chi-squared distribution implied by the Heston model.\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog.sample_from_cf-Tuple{Any, Any}","page":"API Reference","title":"Hedgehog.sample_from_cf","text":"sample_from_cf(rng, ϕ; n=5, kwargs...)\n\nSamples a random variable using its characteristic function ϕ, based on Fourier inversion as in Broadie-Kaya. Uses moment-based heuristics for initial guesses and applies root-finding to invert the CDF.\n\nn: number of standard deviations used to derive the discretization step h\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog.sample_integral_V-Tuple{Any, Any, Hedgehog.HestonDistribution}","page":"API Reference","title":"Hedgehog.sample_integral_V","text":"sample_integral_V(VT, rng, dist::HestonDistribution; kwargs...)\n\nSamples the integral ∫₀ᵗ V_s ds conditional on initial and terminal variance using the characteristic function method.\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog.sde_problem-Union{Tuple{Inputs}, Tuple{Payoff}, Tuple{PricingProblem{Payoff, Inputs}, HestonDynamics, EulerMaruyama}} where {Payoff, Inputs<:HestonInputs}","page":"API Reference","title":"Hedgehog.sde_problem","text":"sde_problem(problem::PricingProblem, ::HestonDynamics, ::EulerMaruyama)\n\nConstructs a HestonProblem for Euler-Maruyama simulation of the Heston model.\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog.sde_problem-Union{Tuple{Inputs}, Tuple{Payoff}, Tuple{PricingProblem{Payoff, Inputs}, HestonDynamics, HestonBroadieKaya}} where {Payoff, Inputs<:HestonInputs}","page":"API Reference","title":"Hedgehog.sde_problem","text":"sde_problem(problem::PricingProblem, ::HestonDynamics, ::HestonBroadieKaya)\n\nConstructs a NoiseProblem using Broadie-Kaya sampling for Heston dynamics.\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog.sde_problem-Union{Tuple{Inputs}, Tuple{Payoff}, Tuple{PricingProblem{Payoff, Inputs}, LognormalDynamics, BlackScholesExact}} where {Payoff, Inputs<:BlackScholesInputs}","page":"API Reference","title":"Hedgehog.sde_problem","text":"sde_problem(problem::PricingProblem, ::LognormalDynamics, ::BlackScholesExact)\n\nConstructs a NoiseProblem for exact simulation of Black-Scholes dynamics.\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog.sde_problem-Union{Tuple{Inputs}, Tuple{Payoff}, Tuple{PricingProblem{Payoff, Inputs}, LognormalDynamics, EulerMaruyama}} where {Payoff, Inputs<:BlackScholesInputs}","page":"API Reference","title":"Hedgehog.sde_problem","text":"sde_problem(problem::PricingProblem, ::LognormalDynamics, ::EulerMaruyama)\n\nConstructs a LogGBMProblem for Euler-Maruyama simulation of Black-Scholes dynamics.\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog.sde_problem-Union{Tuple{M}, Tuple{P}, Tuple{P, M}} where {P<:PricingProblem, M<:MonteCarlo}","page":"API Reference","title":"Hedgehog.sde_problem","text":"sde_problem(problem, method)\n\nDispatches to the appropriate SDE constructor based on the method's dynamics and strategy.\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog.simulate_paths-Union{Tuple{M}, Tuple{Any, M, Hedgehog.Antithetic}} where M<:MonteCarlo","page":"API Reference","title":"Hedgehog.simulate_paths","text":"simulate_paths(sde_prob, method, ::Antithetic)\n\nSimulates paths using antithetic variates for variance reduction.\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog.simulate_paths-Union{Tuple{M}, Tuple{Any, M, Hedgehog.NoVarianceReduction}} where M<:MonteCarlo","page":"API Reference","title":"Hedgehog.simulate_paths","text":"simulate_paths(sde_prob, method, ::NoVarianceReduction)\n\nSimulates paths using standard Monte Carlo (no variance reduction).\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog.solve-Tuple{CalibrationProblem, OptimizerAlgo}","page":"API Reference","title":"Hedgehog.solve","text":"solve(calib::CalibrationProblem, calib_algo::OptimizerAlgo; kwargs...)\n\nCalibrates a basket of pricing problems using an optimization algorithm.\n\nReturns the optimization result, which contains the fitted parameters.\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog.solve-Tuple{CalibrationProblem, RootFinderAlgo}","page":"API Reference","title":"Hedgehog.solve","text":"solve(calib::CalibrationProblem, calib_algo::RootFinderAlgo; kwargs...)\n\nSolves for a single implied parameter (e.g., implied volatility) using root-finding.\n\nReturns the solution object with .u as the calibrated value.\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog.solve-Tuple{SecondOrderGreekProblem, AnalyticGreek, BlackScholesAnalytic}","page":"API Reference","title":"Hedgehog.solve","text":"solve(gprob::SecondOrderGreekProblem, ::AnalyticGreek, ::BlackScholesAnalytic)\n\nSolve a second-order Greek problem using closed-form Black-Scholes formulas.\n\nArguments\n\ngprob: The second-order Greek problem to solve.\n::AnalyticGreek: The method to use (analytic formulas).\n::BlackScholesAnalytic: The pricing method (Black-Scholes analytic).\n\nReturns\n\nA GreekResult containing the calculated second-order Greek.\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog.solve-Union{Tuple{A}, Tuple{P}, Tuple{S}, Tuple{GreekProblem, FiniteDifference{S, A}, P}} where {S<:Hedgehog.FDScheme, P<:Hedgehog.AbstractPricingMethod, A}","page":"API Reference","title":"Hedgehog.solve","text":"solve(gprob::GreekProblem, method::FiniteDifference{S,A}, pricing_method::P) where {S<:FDScheme,P<:AbstractPricingMethod,A}\n\nSolve a first-order Greek problem using finite differences.\n\nArguments\n\ngprob: The Greek problem to solve.\nmethod: Finite difference method configuration.\npricing_method: The method to use for pricing.\n\nReturns\n\nA GreekResult containing the calculated Greek.\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog.solve-Union{Tuple{I}, Tuple{C}, Tuple{B}, Tuple{TE}, Tuple{TS}, Tuple{PricingProblem{VanillaOption{TS, TE, European, B, C}, I}, BlackScholesAnalytic}} where {TS, TE, B, C, I<:BlackScholesInputs}","page":"API Reference","title":"Hedgehog.solve","text":"solve(prob::PricingProblem{VanillaOption{European}}, ::BlackScholesAnalytic) -> AnalyticSolution\n\nComputes the price of a European vanilla option under the Black-Scholes model.\n\nArguments\n\nprob::PricingProblem: The pricing problem, including the payoff and market inputs.\nBlackScholesAnalytic: Marker for the analytic pricing method.\n\nReturns\n\nAnalyticSolution: The priced solution under Black-Scholes assumptions.\n\nNotes\n\nUses the forward measure formulation.\nFalls back to intrinsic value if volatility is zero.\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog.solve-Union{Tuple{I}, Tuple{L}, Tuple{C}, Tuple{B}, Tuple{TE}, Tuple{TS}, Tuple{GreekProblem{PricingProblem{VanillaOption{TS, TE, European, B, C}, I}, L}, AnalyticGreek, BlackScholesAnalytic}} where {TS, TE, B, C, L, I<:BlackScholesInputs}","page":"API Reference","title":"Hedgehog.solve","text":"solve(gprob::GreekProblem{PricingProblem{VanillaOption{TS,TE,European,B,C},I}, L}, ::AnalyticGreek, ::BlackScholesAnalytic) where {TS,TE,B,C,L, I<:BlackScholesInputs}\n\nSolve a first-order Greek problem for European vanilla options using closed-form Black-Scholes formulas.\n\nArguments\n\ngprob: The Greek problem to solve.\n::AnalyticGreek: The method to use (analytic formulas).\n::BlackScholesAnalytic: The pricing method (Black-Scholes analytic).\n\nReturns\n\nA GreekResult containing the calculated Greek.\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog.solve-Union{Tuple{L}, Tuple{P}, Tuple{BatchGreekProblem{P, L}, Hedgehog.GreekMethod, Hedgehog.AbstractPricingMethod}} where {P, L}","page":"API Reference","title":"Hedgehog.solve","text":"solve(gprob::BatchGreekProblem{P,L}, method::GreekMethod, pricing_method::AbstractPricingMethod) where {P,L}\n\nSolve multiple Greek problems simultaneously.\n\nArguments\n\ngprob: The batch Greek problem to solve.\nmethod: The method to use for Greek calculation.\npricing_method: The method to use for pricing.\n\nReturns\n\nA dictionary mapping lenses to their corresponding Greeks.\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog.solve-Union{Tuple{L}, Tuple{S}, Tuple{C}, Tuple{I}, Tuple{TE}, Tuple{TS}, Tuple{PricingProblem{VanillaOption{TS, TE, American, C, S}, I}, L}} where {TS, TE, I<:AbstractMarketInputs, C, S, L<:LSM}","page":"API Reference","title":"Hedgehog.solve","text":"solve(prob::PricingProblem, method::LSM)\n\nPrices an American option using the Least Squares Monte Carlo method.\n\nArguments\n\nprob: A PricingProblem containing an American VanillaOption.\nmethod: An LSM pricing method.\n\nReturns\n\nAn LSMSolution containing price and stopping strategy.\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog.solve-Union{Tuple{M}, Tuple{BasketPricingProblem, M}} where M<:Hedgehog.AbstractPricingMethod","page":"API Reference","title":"Hedgehog.solve","text":"solve(prob::BasketPricingProblem, method)\n\nPrice every payoff in prob with the given pricing method and return a BasketPricingSolution collecting the individual results.\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog.solve-Union{Tuple{P}, Tuple{GreekProblem, ForwardAD, P}} where P<:Hedgehog.AbstractPricingMethod","page":"API Reference","title":"Hedgehog.solve","text":"solve(gprob::GreekProblem, ::ForwardAD, pricing_method::P) where {P<:AbstractPricingMethod}\n\nSolve a first-order Greek problem using automatic differentiation.\n\nArguments\n\ngprob: The Greek problem to solve.\n::ForwardAD: The method to use (automatic differentiation).\npricing_method: The method to use for pricing.\n\nReturns\n\nA named tuple containing the calculated Greek.\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog.solve-Union{Tuple{P}, Tuple{SecondOrderGreekProblem, FiniteDifference, P}} where P<:Hedgehog.AbstractPricingMethod","page":"API Reference","title":"Hedgehog.solve","text":"solve(gprob::SecondOrderGreekProblem, method::FiniteDifference, pricing_method::P) where {P<:AbstractPricingMethod}\n\nSolve a second-order Greek problem using finite differences.\n\nArguments\n\ngprob: The second-order Greek problem to solve.\nmethod: Finite difference method configuration.\npricing_method: The method to use for pricing.\n\nReturns\n\nA GreekResult containing the calculated second-order Greek.\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog.solve-Union{Tuple{P}, Tuple{SecondOrderGreekProblem, ForwardAD, P}} where P<:Hedgehog.AbstractPricingMethod","page":"API Reference","title":"Hedgehog.solve","text":"solve(gprob::SecondOrderGreekProblem, ::ForwardAD, pricing_method::P) where {P<:AbstractPricingMethod}\n\nSolve a second-order Greek problem using automatic differentiation.\n\nArguments\n\ngprob: The second-order Greek problem to solve.\n::ForwardAD: The method to use (automatic differentiation).\npricing_method: The method to use for pricing.\n\nReturns\n\nA GreekResult containing the calculated second-order Greek.\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog.solve-Union{Tuple{S}, Tuple{D}, Tuple{I}, Tuple{C}, Tuple{TE}, Tuple{TS}, Tuple{PricingProblem{VanillaOption{TS, TE, European, C, Spot}, I}, MonteCarlo{D, S}}} where {TS, TE, C, I<:AbstractMarketInputs, D<:Hedgehog.PriceDynamics, S<:Hedgehog.SimulationStrategy}","page":"API Reference","title":"Hedgehog.solve","text":"solve(prob::PricingProblem, method::MonteCarlo)\n\nSolves the pricing problem using Monte Carlo simulation and returns the discounted expected payoff.\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog.spine_tenors-Tuple{RateCurve}","page":"API Reference","title":"Hedgehog.spine_tenors","text":"spine_tenors(curve::RateCurve)\n\nGet the x-values (year fractions) used in the interpolator.\n\nReturns\n\nA vector of year fractions.\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog.spine_zeros-Tuple{RateCurve}","page":"API Reference","title":"Hedgehog.spine_zeros","text":"spine_zeros(curve::RateCurve)\n\nGet the y-values (zero rates) used in the interpolator.\n\nReturns\n\nA vector of zero rates.\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog.to_ticks-Tuple{Dates.DateTime}","page":"API Reference","title":"Hedgehog.to_ticks","text":"to_ticks(x::DateTime)\n\nConvert a DateTime to milliseconds since the Julia Dates module epoch (0000-01-01T00:00:00).\n\nUses Dates.datetime2epochms.\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog.to_ticks-Tuple{Dates.Date}","page":"API Reference","title":"Hedgehog.to_ticks","text":"to_ticks(x::Date)\n\nConvert a Date to milliseconds since the Julia Dates module epoch (0000-01-01).\n\nNote: This is calculated by converting the Date to days since epoch  (Dates.date2epochdays) and multiplying by MILLISECONDS_IN_DAY.\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog.to_ticks-Tuple{Real}","page":"API Reference","title":"Hedgehog.to_ticks","text":"to_ticks(x::Real)\n\nAssume x is already a timestamp in milliseconds since the Julia Dates module epoch (0000-01-01T00:00:00) and return it unchanged.\n\nUsed to normalize mixed inputs (e.g., Date, DateTime, Real) to a common tick representation for calculations like yearfrac or add_yearfrac.\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog.update_stopping_info!-Union{Tuple{U}, Tuple{S}, Tuple{T}, Tuple{Array{Tuple{Int64, U}, 1}, Vector{Int64}, Vector{T}, Vector{S}, Int64}} where {T, S, U}","page":"API Reference","title":"Hedgehog.update_stopping_info!","text":"update_stopping_info!(\n    stopping_info::Vector{Tuple{Int, U}},\n    paths::Vector{Int},\n    cont_value::Vector{T},\n    payoff_t::Vector{S},\n    t::Int\n)\n\nUpdates the stopping times and values in-place based on immediate vs. continuation value comparison.\n\nArguments\n\nstopping_info: Current best (time, value) for each path.\npaths: Indices of in-the-money paths.\ncont_value: Estimated continuation values.\npayoff_t: Immediate exercise values.\nt: Current time index.\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog.yearfrac-Tuple{Any, Any}","page":"API Reference","title":"Hedgehog.yearfrac","text":"yearfrac(start, stop)\n\nCompute the ACT/365 year fraction between two time points.\n\nInputs start and stop can be Date, DateTime, or ticks (Int or Float64). If ticks are provided, they are assumed to be milliseconds since the Julia Dates module epoch (0000-01-01T00:00:00), consistent with the output of to_ticks.\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog.yearfrac-Tuple{Dates.AbstractTime}","page":"API Reference","title":"Hedgehog.yearfrac","text":"yearfrac(p::AbstractTime)\n\nCompute the ACT/365 year fraction from a Period object (e.g., Year(1), Day(180)). It allows also for CompoundPeriod, and even Dates, interpreting them as time periods from year 0 of the Gregorian calendar. Calculates the duration represented by the period in milliseconds and divides by MILLISECONDS_IN_YEAR_365.\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog.zero_rate-Union{Tuple{D}, Tuple{R}, Tuple{R, D}} where {R<:Hedgehog.AbstractRateCurve, D<:Dates.TimeType}","page":"API Reference","title":"Hedgehog.zero_rate","text":"zero_rate(curve::AbstractRateCurve, t::TimeType)\n\nCompute the zero rate for a Date or DateTime.\n\nReturns\n\nContinuously compounded rate as a real number.\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog.zero_rate-Union{Tuple{T}, Tuple{RateCurve, T}} where T<:Number","page":"API Reference","title":"Hedgehog.zero_rate","text":"zero_rate(curve::AbstractRateCurve, ticks::Number)\n\nCompute the zero rate for a time point given in ticks.\n\nReturns\n\nContinuously compounded rate as a real number.\n\n\n\n\n\n","category":"method"},{"location":"api/#Hedgehog.zero_rate_yf-Union{Tuple{R}, Tuple{RateCurve, R}} where R<:Number","page":"API Reference","title":"Hedgehog.zero_rate_yf","text":"zero_rate_yf(curve::AbstractRateCurve, yf::Number)\n\nCompute the zero rate from a year fraction.\n\nReturns\n\nContinuously compounded rate as a real number.\n\n\n\n\n\n","category":"method"},{"location":"interactive/#Interactive-Examples","page":"Interactive Examples","title":"Interactive Examples","text":"","category":"section"},{"location":"interactive/","page":"Interactive Examples","title":"Interactive Examples","text":"Hedgehog.jl includes several interactive Pluto notebooks that demonstrate key concepts in derivatives pricing with rich visualizations and real-time parameter adjustment.","category":"page"},{"location":"interactive/#Available-Notebooks","page":"Interactive Examples","title":"Available Notebooks","text":"","category":"section"},{"location":"interactive/","page":"Interactive Examples","title":"Interactive Examples","text":"Black-Scholes Pricing - Interactive exploration of option prices, delta, and vega as functions of spot price and volatility\nMonte Carlo Methods - Visualization of price convergence, path generation, and variance reduction techniques","category":"page"},{"location":"interactive/","page":"Interactive Examples","title":"Interactive Examples","text":"The notebooks demonstrate key features of Hedgehog.jl:","category":"page"},{"location":"interactive/","page":"Interactive Examples","title":"Interactive Examples","text":"Black-Scholes Notebook:","category":"page"},{"location":"interactive/","page":"Interactive Examples","title":"Interactive Examples","text":"Visualization of vanilla option payoffs\nInteractive sliders to see how volatility affects option prices\nDelta and vega curves across different strike prices\nReal-time calculation using Hedgehog's analytical pricing methods","category":"page"},{"location":"interactive/","page":"Interactive Examples","title":"Interactive Examples","text":"Monte Carlo Notebook:","category":"page"},{"location":"interactive/","page":"Interactive Examples","title":"Interactive Examples","text":"Path generation visualization using different simulation strategies\nConvergence analysis as the number of simulations increases\nDemonstration of variance reduction techniques\nIntegration with automatic differentiation for Greeks calculation","category":"page"},{"location":"interactive/#Running-the-Notebooks","page":"Interactive Examples","title":"Running the Notebooks","text":"","category":"section"},{"location":"interactive/","page":"Interactive Examples","title":"Interactive Examples","text":"To run these notebooks, you'll need to have Pluto.jl installed:","category":"page"},{"location":"interactive/","page":"Interactive Examples","title":"Interactive Examples","text":"using Pkg\nPkg.add(\"Pluto\")","category":"page"},{"location":"interactive/","page":"Interactive Examples","title":"Interactive Examples","text":"Then, you can open any notebook with:","category":"page"},{"location":"interactive/","page":"Interactive Examples","title":"Interactive Examples","text":"using Pluto\nPluto.run(notebook=\"path/to/Hedgehog.jl/examples/notebooks/pluto_black_scholes.jl\")","category":"page"},{"location":"interactive/","page":"Interactive Examples","title":"Interactive Examples","text":"For the best experience, make sure you have all dependencies installed by first running:","category":"page"},{"location":"interactive/","page":"Interactive Examples","title":"Interactive Examples","text":"# Navigate to the examples directory\ncd(\"path/to/Hedgehog.jl/examples\")\nusing Pkg\nPkg.activate(\".\")\nPkg.instantiate()","category":"page"},{"location":"interactive/","page":"Interactive Examples","title":"Interactive Examples","text":"These interactive examples complement the static documentation by allowing you to experiment with different parameters and see the immediate effects on pricing and risk measures, building intuition about derivatives pricing concepts.","category":"page"},{"location":"pricing_methods/#Pricing-Methods","page":"Pricing Methods","title":"Pricing Methods","text":"","category":"section"},{"location":"pricing_methods/","page":"Pricing Methods","title":"Pricing Methods","text":"Hedgehog implements various pricing methods as subtypes of AbstractPricingMethod.   Each method can be used with the unified solve interface.","category":"page"},{"location":"pricing_methods/","page":"Pricing Methods","title":"Pricing Methods","text":"","category":"page"},{"location":"pricing_methods/#[BlackScholesAnalytic](@ref)","page":"Pricing Methods","title":"BlackScholesAnalytic","text":"","category":"section"},{"location":"pricing_methods/","page":"Pricing Methods","title":"Pricing Methods","text":"The BlackScholesAnalytic method implements the closed-form Black-Scholes formula for European vanilla options. It provides exact pricing for call and put options under lognormal dynamics with constant volatility and interest rate.","category":"page"},{"location":"pricing_methods/","page":"Pricing Methods","title":"Pricing Methods","text":"solution = solve(problem, BlackScholesAnalytic())","category":"page"},{"location":"pricing_methods/","page":"Pricing Methods","title":"Pricing Methods","text":"","category":"page"},{"location":"pricing_methods/#[CoxRossRubinsteinMethod](@ref)","page":"Pricing Methods","title":"CoxRossRubinsteinMethod","text":"","category":"section"},{"location":"pricing_methods/","page":"Pricing Methods","title":"Pricing Methods","text":"The CoxRossRubinsteinMethod implements a binomial tree approach for pricing both European and American options. It discretizes the underlying price process into a lattice of possible future prices and uses backward induction to determine the option value.","category":"page"},{"location":"pricing_methods/","page":"Pricing Methods","title":"Pricing Methods","text":"solution = solve(problem, CoxRossRubinsteinMethod(800))  # 800 time steps","category":"page"},{"location":"pricing_methods/","page":"Pricing Methods","title":"Pricing Methods","text":"","category":"page"},{"location":"pricing_methods/#[MonteCarlo](@ref)","page":"Pricing Methods","title":"MonteCarlo","text":"","category":"section"},{"location":"pricing_methods/","page":"Pricing Methods","title":"Pricing Methods","text":"The MonteCarlo method simulates multiple paths of the underlying price process and averages the resulting payoffs to estimate the option price. It's highly flexible and can be configured with different dynamics, simulation strategies, and variance reduction techniques.","category":"page"},{"location":"pricing_methods/","page":"Pricing Methods","title":"Pricing Methods","text":"mc_method = MonteCarlo(\n    LognormalDynamics(),\n    BlackScholesExact(),\n    SimulationConfig(10_000)  # 10,000 paths\n)\nsolution = solve(problem, mc_method)","category":"page"},{"location":"pricing_methods/","page":"Pricing Methods","title":"Pricing Methods","text":"For more details on configuration options, see:","category":"page"},{"location":"pricing_methods/","page":"Pricing Methods","title":"Pricing Methods","text":"LognormalDynamics\nBlackScholesExact\nSimulationConfig","category":"page"},{"location":"pricing_methods/","page":"Pricing Methods","title":"Pricing Methods","text":"","category":"page"},{"location":"pricing_methods/#[LSM](@ref)","page":"Pricing Methods","title":"LSM","text":"","category":"section"},{"location":"pricing_methods/","page":"Pricing Methods","title":"Pricing Methods","text":"The LSM (Least Squares Monte Carlo) method implements the Longstaff-Schwartz algorithm for pricing American options via Monte Carlo simulation. It uses polynomial regression to estimate continuation values at each exercise opportunity.","category":"page"},{"location":"pricing_methods/","page":"Pricing Methods","title":"Pricing Methods","text":"lsm_method = LSM(\n    LognormalDynamics(),\n    BlackScholesExact(),\n    SimulationConfig(10_000),\n    5  # Polynomial degree for regression\n)\nsolution = solve(problem, lsm_method)","category":"page"},{"location":"pricing_methods/","page":"Pricing Methods","title":"Pricing Methods","text":"","category":"page"},{"location":"pricing_methods/#[CarrMadan](@ref)","page":"Pricing Methods","title":"CarrMadan","text":"","category":"section"},{"location":"pricing_methods/","page":"Pricing Methods","title":"Pricing Methods","text":"The CarrMadan method uses Fourier transform techniques to price options under general exponential Lévy models. It's particularly useful for stochastic volatility models like Heston, where the characteristic function is known in closed form.","category":"page"},{"location":"pricing_methods/","page":"Pricing Methods","title":"Pricing Methods","text":"carr_madan_method = CarrMadan(1.0, 32.0, HestonDynamics())\nsolution = solve(problem, carr_madan_method)","category":"page"},{"location":"pricing_methods/","page":"Pricing Methods","title":"Pricing Methods","text":"For more details on Heston dynamics, see HestonDynamics.","category":"page"},{"location":"derivatives_pricing_roadmap/#Derivatives-Pricing-Library-—-Roadmap-Checklist-(Updated)","page":"Roadmap","title":"✅ Derivatives Pricing Library — Roadmap Checklist (Updated)","text":"","category":"section"},{"location":"derivatives_pricing_roadmap/","page":"Roadmap","title":"Roadmap","text":"","category":"page"},{"location":"derivatives_pricing_roadmap/#PHASE-1-—-Core-Pricing-Engine-[-Completed]","page":"Roadmap","title":"PHASE 1 — Core Pricing Engine [✅ Completed]","text":"","category":"section"},{"location":"derivatives_pricing_roadmap/","page":"Roadmap","title":"Roadmap","text":"[x] Black-Scholes pricing (analytic, MC: exact + Euler)\n[x] Heston pricing (Euler + Broadie–Kaya)\n[x] Binomial tree (European & American)\n[x] Least Squares Monte Carlo (LSM)\n[x] Carr–Madan method (FFT)\n[x] Pricer structure with method, marketinputs, payoff\n[x] Test suite with unit tests and basic price agreements","category":"page"},{"location":"derivatives_pricing_roadmap/","page":"Roadmap","title":"Roadmap","text":"","category":"page"},{"location":"derivatives_pricing_roadmap/#PHASE-2-—-Market-Inputs-and-Calibration-Basics-[-Completed]","page":"Roadmap","title":"PHASE 2 — Market Inputs & Calibration Basics [✅ Completed]","text":"","category":"section"},{"location":"derivatives_pricing_roadmap/","page":"Roadmap","title":"Roadmap","text":"[x] BSVolSurface with rectangular grid + interpolation and get_vol(t) accessor\n[x] Implied vol inversion for vanilla options\n[x] calibrate_vol_surface(quotes) from market prices\n[x] DiscountCurve (flat, piecewise) and df(t) accessor\n[x] Unit tests: vol/curve access, interpolation, smoke pricing\n[x] Rate Curves: Usage instead of constant rates, convenience constructors","category":"page"},{"location":"derivatives_pricing_roadmap/","page":"Roadmap","title":"Roadmap","text":"","category":"page"},{"location":"derivatives_pricing_roadmap/#PHASE-3-—-Greeks-and-Calibration-Infrastructure-[-Completed]","page":"Roadmap","title":"PHASE 3 — Greeks & Calibration Infrastructure [✅ Completed]","text":"","category":"section"},{"location":"derivatives_pricing_roadmap/","page":"Roadmap","title":"Roadmap","text":"[x] Implement GreekProblem and solve with support for:\n[x] Finite differences (forward, backward, central)\n[x] Forward AD\n[x] Analytic Greeks for Black-Scholes\n[x] Optional: AD for Monte Carlo methods\n[x] Plug Greeks into pricing pipeline with consistent API\n[x] Develop modular calibration system:\n[x] Residual-based calibration engine\n[x] Objective functions from market quotes\n[x] Support for different pricer-model combinations\n[x] Heston calibration to implied volatility surface\n[x] Unit tests: Greeks accuracy vs known formulas, calibration residual shapes","category":"page"},{"location":"derivatives_pricing_roadmap/","page":"Roadmap","title":"Roadmap","text":"","category":"page"},{"location":"derivatives_pricing_roadmap/#PHASE-3.5-—-Monte-Carlo-Enhancements-[-Completed]","page":"Roadmap","title":"PHASE 3.5 — Monte Carlo Enhancements [✅ Completed]","text":"","category":"section"},{"location":"derivatives_pricing_roadmap/","page":"Roadmap","title":"Roadmap","text":"[x] Add antithetic variates toggle to MonteCarlo method (Discrete and Exact Black-Scholes [x], Discrete and Exact Heston [x])\n[x] Unit tests: check variance reduction and correctness vs analytic prices\n[x] Seed reproducibility: allow full control over RNG seeds (for all MC types)\n[x] Refactor MC framework to support seed injection and custom ensemble configs\n[x] Optional: design placeholder for MCStrategy, but defer advanced variance reduction","category":"page"},{"location":"derivatives_pricing_roadmap/","page":"Roadmap","title":"Roadmap","text":"","category":"page"},{"location":"derivatives_pricing_roadmap/#PHASE-4-—-Polishing-and-Pre-Release-Prep-[-Completed]","page":"Roadmap","title":"🛠 PHASE 4 — Polishing & Pre-Release Prep [✅ Completed]","text":"","category":"section"},{"location":"derivatives_pricing_roadmap/","page":"Roadmap","title":"Roadmap","text":"🌟 Goal: Registry submission with clean, reproducible functionality and docs","category":"page"},{"location":"derivatives_pricing_roadmap/","page":"Roadmap","title":"Roadmap","text":"[x] Public API audit and finalization\n[x] Add docstrings for all exported types/functions\n[x] Create /docs/ folder with basic Documenter.jl setup\n[x] Include example scripts: pricing, Greeks, calibration\n[x] Add Project.toml metadata (UUID, compat)\n[x] Ensure full test suite runs via Pkg.test()\n[x] CI: GitHub Actions with coverage and doc build\n[x] Tag v0.1.0 and submit to Julia registry\n[x] Soft launch: annunce on JuliaDiscourse","category":"page"},{"location":"derivatives_pricing_roadmap/#PHASE-4.5-—-Basic-Jump-support","page":"Roadmap","title":"PHASE 4.5 — Basic Jump support","text":"","category":"section"},{"location":"derivatives_pricing_roadmap/","page":"Roadmap","title":"Roadmap","text":"[ ] Merton model with Carr Madan\n[ ] Merton model with Montecarlo","category":"page"},{"location":"derivatives_pricing_roadmap/#PHASE-5-—-Structured-Payoffs","page":"Roadmap","title":"PHASE 5 — Structured Payoffs","text":"","category":"section"},{"location":"derivatives_pricing_roadmap/","page":"Roadmap","title":"Roadmap","text":"[ ] Arithmetic Asian pricing via Monte Carlo\n[ ] Geometric Asian pricing via closed-form\n[ ] Digital options (cash-or-nothing, asset-or-nothing)\n[ ] Barrier options (up/down, knock-in/out, discrete monitoring)\n[ ] Extend Payoff with Monitoring / Averaging modifiers\n[ ] Unit tests: price agreement across methods, monitoring edge cases","category":"page"},{"location":"derivatives_pricing_roadmap/","page":"Roadmap","title":"Roadmap","text":"","category":"page"},{"location":"derivatives_pricing_roadmap/#PHASE-6-—-Interest-Rate-Products-and-Models","page":"Roadmap","title":"PHASE 6 — Interest Rate Products & Models","text":"","category":"section"},{"location":"derivatives_pricing_roadmap/","page":"Roadmap","title":"Roadmap","text":"[ ] Implement zero-coupon and fixed-coupon bond pricing\n[ ] Build FRA and IRS support with schedule engine and stub logic\n[ ] Cap/floor pricing using Black formula\n[ ] Hull–White short rate model\n[ ] Swaption pricing via Jamshidian decomposition or PDE method\n[ ] Basic CDS pricing with flat hazard rate model\n[ ] Unit tests: replication of swaps via bond strips, curve usage, date handling","category":"page"},{"location":"derivatives_pricing_roadmap/","page":"Roadmap","title":"Roadmap","text":"","category":"page"},{"location":"derivatives_pricing_roadmap/#PHASE-7-—-Multi-Curve-Support-and-Calibration","page":"Roadmap","title":"PHASE 7 — Multi-Curve Support & Calibration","text":"","category":"section"},{"location":"derivatives_pricing_roadmap/","page":"Roadmap","title":"Roadmap","text":"[ ] Introduce multi-curve framework (OIS + forwarding curves)\n[ ] Curve bootstrapping: deposit, futures, swaps\n[ ] Curve interpolation: ZC rates, discount factors, log-linear extrapolation\n[ ] Integrate multi-curve into FRA, IRS, caps/floors pricing\n[ ] Unit tests: bootstrapping accuracy, multi-curve vs single-curve comparisons","category":"page"},{"location":"derivatives_pricing_roadmap/","page":"Roadmap","title":"Roadmap","text":"","category":"page"},{"location":"derivatives_pricing_roadmap/#PHASE-7.5-—-PDE-Framework","page":"Roadmap","title":"PHASE 7.5 — PDE Framework","text":"","category":"section"},{"location":"derivatives_pricing_roadmap/","page":"Roadmap","title":"Roadmap","text":"[ ] Implement Crank–Nicolson solver for Black-Scholes PDE\n[ ] Define PDEProblem type with boundary conditions and solver settings\n[ ] Generalize solver infrastructure for future PDE models\n[ ] Unit tests: convergence checks, price agreement with analytic/MC methods","category":"page"},{"location":"derivatives_pricing_roadmap/","page":"Roadmap","title":"Roadmap","text":"","category":"page"},{"location":"derivatives_pricing_roadmap/#PHASE-8-—-SABR,-Local-Vol,-Rough-Vol","page":"Roadmap","title":"PHASE 8 — SABR, Local Vol, Rough Vol","text":"","category":"section"},{"location":"derivatives_pricing_roadmap/","page":"Roadmap","title":"Roadmap","text":"[ ] SABR model implementation (Hagan approximation)\n[ ] Calibration to vanilla vol surface\n[ ] Dupire local vol generation from calibrated surface\n[ ] Rough Heston or rBergomi sampling engine\n[ ] Fourier or Monte Carlo pricing for rough volatility models\n[ ] Unit tests: calibration error metrics, simulation path sanity checks","category":"page"},{"location":"derivatives_pricing_roadmap/","page":"Roadmap","title":"Roadmap","text":"","category":"page"},{"location":"derivatives_pricing_roadmap/#PHASE-9-—-Robustness-and-Performance","page":"Roadmap","title":"PHASE 9 — Robustness & Performance","text":"","category":"section"},{"location":"derivatives_pricing_roadmap/","page":"Roadmap","title":"Roadmap","text":"[ ] Edge case test suite: deep ITM/OTM, short maturity, extreme vol\n[ ] Sensitivity exploration tools (Greeks wrt model parameters)\n[ ] Allocation-free Monte Carlo and LSM refactoring\n[ ] Batch pricing support for performance testing\n[ ] Parallel/multithreaded MC and calibration support\n[ ] Optional: GPU backend for simulation\n[ ] CI: Full unit test and regression test coverage, GitHub Actions setup","category":"page"},{"location":"derivatives_pricing_roadmap/","page":"Roadmap","title":"Roadmap","text":"","category":"page"},{"location":"derivatives_pricing_roadmap/#PHASE-10-—-Model-Free-Pricing-and-Arbitrage-Detection","page":"Roadmap","title":"PHASE 10 — Model-Free Pricing & Arbitrage Detection","text":"","category":"section"},{"location":"derivatives_pricing_roadmap/","page":"Roadmap","title":"Roadmap","text":"[ ] Risk-neutral density extraction from call spread surface\n[ ] Variance swap pricing via replication\n[ ] Digital option replication using spreads\n[ ] Arbitrage checks: calendar spreads, butterfly arbitrage\n[ ] Super-replication bounds for exotic payoffs\n[ ] Unit tests: convexity and arbitrage consistency, replication sanity","category":"page"},{"location":"derivatives_pricing_roadmap/","page":"Roadmap","title":"Roadmap","text":"","category":"page"},{"location":"derivatives_pricing_roadmap/#PHASE-11-—-Documentation-and-Launch-Prep","page":"Roadmap","title":"PHASE 11 — Documentation & Launch Prep","text":"","category":"section"},{"location":"derivatives_pricing_roadmap/","page":"Roadmap","title":"Roadmap","text":"[ ] Full docstrings for all exported types and functions\n[ ] Notebooks covering pricing, Greeks, calibration, and structured payoffs\n[ ] CONTRIBUTING.md and internal dev onboarding guide\n[ ] Smoke-tested example scripts folder\n[ ] Test coverage badge and CI status reporting\n[ ] Prepare for public release: package registry, landing README\n[ ] Soft launch with trusted peers; optionally post to LinkedIn, Discourse","category":"page"},{"location":"derivatives_pricing_roadmap/","page":"Roadmap","title":"Roadmap","text":"","category":"page"},{"location":"derivatives_pricing_roadmap/#PHASE-12-—-Optional-Extensions","page":"Roadmap","title":"PHASE 12 — Optional Extensions","text":"","category":"section"},{"location":"derivatives_pricing_roadmap/","page":"Roadmap","title":"Roadmap","text":"[ ] Control variates using Black-Scholes\n[ ] Stratified sampling / quasi-random generation\n[ ] REST API or service wrapper for pricing/calibration endpoints\n[ ] Pluto.jl-based interactive pricing UI\n[ ] Real-time batch pricing and risk engine prototype\n[ ] Signature-based models (rough paths theory)\n[ ] Structured product builder (range accruals, callable notes)\n[ ] QUAD method revisitation and benchmarking","category":"page"},{"location":"greeks_doc/#Greeks-Calculation","page":"Greek Methods","title":"Greeks Calculation","text":"","category":"section"},{"location":"greeks_doc/","page":"Greek Methods","title":"Greek Methods","text":"Hedgehog implements various methods for computing sensitivities (Greeks) of derivative prices, using a unified solve interface with the GreekProblem type.","category":"page"},{"location":"greeks_doc/","page":"Greek Methods","title":"Greek Methods","text":"","category":"page"},{"location":"greeks_doc/#Greek-Methods","page":"Greek Methods","title":"Greek Methods","text":"","category":"section"},{"location":"greeks_doc/#ForwardAD","page":"Greek Methods","title":"ForwardAD","text":"","category":"section"},{"location":"greeks_doc/","page":"Greek Methods","title":"Greek Methods","text":"The ForwardAD method uses forward-mode automatic differentiation to compute sensitivities. It typically provides precise results with good performance, especially for first-order Greeks.","category":"page"},{"location":"greeks_doc/","page":"Greek Methods","title":"Greek Methods","text":"# Calculate delta using automatic differentiation\nspot_lens = @optic _.market_inputs.spot\ndelta_problem = GreekProblem(pricing_problem, spot_lens)\nsolution = solve(delta_problem, ForwardAD(), BlackScholesAnalytic())\ndelta = solution.greek","category":"page"},{"location":"greeks_doc/","page":"Greek Methods","title":"Greek Methods","text":"","category":"page"},{"location":"greeks_doc/#FiniteDifference","page":"Greek Methods","title":"FiniteDifference","text":"","category":"section"},{"location":"greeks_doc/","page":"Greek Methods","title":"Greek Methods","text":"The FiniteDifference method approximates derivatives using numerical differencing. It provides flexibility in choice of scheme (forward, backward, central) and step size.","category":"page"},{"location":"greeks_doc/","page":"Greek Methods","title":"Greek Methods","text":"# Calculate delta using central finite differences\nfd_method = FiniteDifference(1e-4)  # 1e-4 is the step size\nsolution = solve(delta_problem, fd_method, BlackScholesAnalytic())\ndelta = solution.greek","category":"page"},{"location":"greeks_doc/","page":"Greek Methods","title":"Greek Methods","text":"","category":"page"},{"location":"greeks_doc/#AnalyticGreek","page":"Greek Methods","title":"AnalyticGreek","text":"","category":"section"},{"location":"greeks_doc/","page":"Greek Methods","title":"Greek Methods","text":"The AnalyticGreek method uses closed-form solutions for sensitivities when available. Currently supports Black-Scholes model Greeks (delta, gamma, vega, theta, rho).","category":"page"},{"location":"greeks_doc/","page":"Greek Methods","title":"Greek Methods","text":"# Calculate delta using analytical formulas\nsolution = solve(delta_problem, AnalyticGreek(), BlackScholesAnalytic())\ndelta = solution.greek","category":"page"},{"location":"greeks_doc/","page":"Greek Methods","title":"Greek Methods","text":"","category":"page"},{"location":"greeks_doc/#Problem-Types","page":"Greek Methods","title":"Problem Types","text":"","category":"section"},{"location":"greeks_doc/#GreekProblem","page":"Greek Methods","title":"GreekProblem","text":"","category":"section"},{"location":"greeks_doc/","page":"Greek Methods","title":"Greek Methods","text":"A GreekProblem represents a first-order sensitivity calculation with respect to a specific parameter.","category":"page"},{"location":"greeks_doc/","page":"Greek Methods","title":"Greek Methods","text":"GreekProblem(pricing_problem, lens)","category":"page"},{"location":"greeks_doc/","page":"Greek Methods","title":"Greek Methods","text":"where lens is an accessor (from Accessors.jl) that specifies which parameter to differentiate with respect to.","category":"page"},{"location":"greeks_doc/","page":"Greek Methods","title":"Greek Methods","text":"","category":"page"},{"location":"greeks_doc/#SecondOrderGreekProblem","page":"Greek Methods","title":"SecondOrderGreekProblem","text":"","category":"section"},{"location":"greeks_doc/","page":"Greek Methods","title":"Greek Methods","text":"A SecondOrderGreekProblem represents a second-order sensitivity (e.g., gamma, volga) calculation.","category":"page"},{"location":"greeks_doc/","page":"Greek Methods","title":"Greek Methods","text":"SecondOrderGreekProblem(pricing_problem, lens1, lens2)","category":"page"},{"location":"greeks_doc/","page":"Greek Methods","title":"Greek Methods","text":"When lens1 and lens2 are identical, this computes a pure second derivative. When they differ, it computes a mixed partial derivative.","category":"page"},{"location":"greeks_doc/","page":"Greek Methods","title":"Greek Methods","text":"","category":"page"},{"location":"greeks_doc/#BatchGreekProblem","page":"Greek Methods","title":"BatchGreekProblem","text":"","category":"section"},{"location":"greeks_doc/","page":"Greek Methods","title":"Greek Methods","text":"The BatchGreekProblem allows calculating multiple Greeks in a single operation for efficiency.","category":"page"},{"location":"greeks_doc/","page":"Greek Methods","title":"Greek Methods","text":"spot_lens = @optic _.market_inputs.spot\nvol_lens = VolLens(1,1)\nbatch_problem = BatchGreekProblem(pricing_problem, (spot_lens, vol_lens))\ngreeks = solve(batch_problem, ForwardAD(), BlackScholesAnalytic())\ndelta = greeks[spot_lens]\nvega = greeks[vol_lens]","category":"page"},{"location":"greeks_doc/","page":"Greek Methods","title":"Greek Methods","text":"","category":"page"},{"location":"greeks_doc/#Common-Parameter-Lenses","page":"Greek Methods","title":"Common Parameter Lenses","text":"","category":"section"},{"location":"greeks_doc/","page":"Greek Methods","title":"Greek Methods","text":"Hedgehog provides several accessor lenses for targeting specific parameters:","category":"page"},{"location":"greeks_doc/","page":"Greek Methods","title":"Greek Methods","text":"SpotLens(): Accesses the spot price (for delta and gamma)\nVolLens(i,j): Accesses volatility at index (i,j) in a surface (for vega and volga)\n@optic _.market_inputs.spot: Alternative for spot price using the Accessors.jl macro\n@optic _.payoff.expiry: For theta (time sensitivity)\nZeroRateSpineLens(i): For rho (interest rate sensitivity) for spine point i","category":"page"},{"location":"greeks_doc/#Examples","page":"Greek Methods","title":"Examples","text":"","category":"section"},{"location":"greeks_doc/#Calculating-Delta-and-Gamma","page":"Greek Methods","title":"Calculating Delta and Gamma","text":"","category":"section"},{"location":"greeks_doc/","page":"Greek Methods","title":"Greek Methods","text":"using Hedgehog\nusing Accessors  # For @optic macro\nusing Dates\n\n# Define option and market inputs\nstrike = 100.0\nexpiry = Date(2023, 12, 31)\nspot = 100.0\nvol = 0.20\nrate = 0.05\nreference_date = Date(2023, 1, 1)\n\npayoff = VanillaOption(strike, expiry, European(), Call(), Spot())\nmarket = BlackScholesInputs(reference_date, rate, spot, vol)\nprob = PricingProblem(payoff, market)\n\n# Define lens for spot price\nspot_lens = @optic _.market_inputs.spot\n\n# Calculate delta using various methods\ndelta_fd = solve(GreekProblem(prob, spot_lens), FiniteDifference(1e-4), BlackScholesAnalytic()).greek\ndelta_ad = solve(GreekProblem(prob, spot_lens), ForwardAD(), BlackScholesAnalytic()).greek\ndelta_an = solve(GreekProblem(prob, spot_lens), AnalyticGreek(), BlackScholesAnalytic()).greek\n\n# Calculate gamma (second-order sensitivity to spot)\ngamma_prob = SecondOrderGreekProblem(prob, spot_lens, spot_lens)\ngamma = solve(gamma_prob, ForwardAD(), BlackScholesAnalytic()).greek","category":"page"},{"location":"greeks_doc/#Calculating-Vega","page":"Greek Methods","title":"Calculating Vega","text":"","category":"section"},{"location":"greeks_doc/","page":"Greek Methods","title":"Greek Methods","text":"# Define lens for volatility\nvol_lens = VolLens(1, 1)\n\n# Calculate vega\nvega_prob = GreekProblem(prob, vol_lens)\nvega = solve(vega_prob, ForwardAD(), BlackScholesAnalytic()).greek","category":"page"},{"location":"greeks_doc/#Batch-Greek-Calculation","page":"Greek Methods","title":"Batch Greek Calculation","text":"","category":"section"},{"location":"greeks_doc/","page":"Greek Methods","title":"Greek Methods","text":"# Calculate multiple Greeks efficiently\nrate_lens = ZeroRateSpineLens(1) \nbatch_prob = BatchGreekProblem(prob, (spot_lens, vol_lens, rate_lens))\nall_greeks = solve(batch_prob, ForwardAD(), BlackScholesAnalytic())\n\n# Extract individual Greeks\ndelta = all_greeks[spot_lens]\nvega = all_greeks[vol_lens]\nrho = all_greeks[rate_lens]","category":"page"},{"location":"greeks_doc/#Monte-Carlo-Greeks","page":"Greek Methods","title":"Monte Carlo Greeks","text":"","category":"section"},{"location":"greeks_doc/","page":"Greek Methods","title":"Greek Methods","text":"Greeks can also be calculated for Monte Carlo pricing methods:","category":"page"},{"location":"greeks_doc/","page":"Greek Methods","title":"Greek Methods","text":"# Define Monte Carlo method\nmc_method = MonteCarlo(\n    LognormalDynamics(),\n    BlackScholesExact(),\n    SimulationConfig(10_000)\n)\n\n# Calculate delta using AD with Monte Carlo\ndelta_mc = solve(GreekProblem(prob, spot_lens), ForwardAD(), mc_method).greek","category":"page"},{"location":"#Hedgehog.jl","page":"Home","title":"Hedgehog.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to Hedgehog.jl — a modular, high-performance derivatives pricing library written in Julia.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Hedgehog is designed with composability and clarity in mind, targeting quantitative finance professionals, academics, and advanced users who need full control over models, calibration, and pricing algorithms.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Features","page":"Home","title":"🚀 Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"✅ Modular pricers with support for Monte Carlo, PDE, Fourier, and analytic methods  \n✅ Support for volatility surfaces, rate curves, and calibration infrastructure  \n✅ Composable payoffs and flexible pricing problems  \n✅ Automatic and finite difference Greeks using lens-based access  \n✅ Simulation strategies and exact SDE schemes (e.g., Broadie-Kaya for Heston)  \n✅ Performance-aware design with full AD support  \n✅ Full test suite and example scripts","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Philosophy","page":"Home","title":"🧠 Philosophy","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Hedgehog treats models, payoffs, and pricing methods as first-class, composable objects, allowing:","category":"page"},{"location":"","page":"Home","title":"Home","text":"easy experimentation with new models,\nseparation of concerns (dynamics, simulation, pricing),\nand fast iteration on complex structures like baskets or multi-curve setups.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Getting-Started","page":"Home","title":"💡 Getting Started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Install from source:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(url=\"https://github.com/aleCombi/Hedgehog.jl\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"Basic example:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Hedgehog\nusing Dates\nusing Accessors  # For @optic macro\n\n# Define the option parameters\nstrike = 100.0\nreference_date = Date(2023, 1, 1)\nexpiry_date = reference_date + Year(1)\nrate = 0.05\nspot = 100.0\nsigma = 0.20\n\n# Create the payoff and market inputs\npayoff = VanillaOption(strike, expiry_date, European(), Call(), Spot())\nmarket_inputs = BlackScholesInputs(reference_date, rate, spot, sigma)\n\n# Create pricing problem and solve it\nproblem = PricingProblem(payoff, market_inputs)\nsolution = solve(problem, BlackScholesAnalytic())\n\n# Access the price\nprintln(\"Option price: \", solution.price)\n\n# Calculate delta (sensitivity to spot price)\nspot_lens = @optic _.market_inputs.spot\ndelta = solve(GreekProblem(problem, spot_lens), ForwardAD(), BlackScholesAnalytic()).greek\nprintln(\"Delta: \", delta)","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Roadmap","page":"Home","title":"🛣️ Roadmap","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Hedgehog development follows a structured roadmap with clearly defined phases:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Core pricing engines\nVolatility surfaces and yield curves\nCalibration and sensitivities\nPDE solvers and early exercise methods\nAdvanced stochastic volatility and local volatility models\nPortfolio and basket pricing\nPerformance and production features\nFinal polish and publication","category":"page"},{"location":"","page":"Home","title":"Home","text":"Check the internal ADRs for more details on the design and implementation plan.","category":"page"}]
}
